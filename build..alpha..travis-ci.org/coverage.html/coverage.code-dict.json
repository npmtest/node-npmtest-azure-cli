{"/home/travis/build/npmtest/node-npmtest-azure-cli/test.js":"/* istanbul instrument in package npmtest_azure_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-azure-cli/lib.npmtest_azure_cli.js":"/* istanbul instrument in package npmtest_azure_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_azure_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_azure_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-azure-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-azure-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_azure_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_azure_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_azure_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_azure_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_azure_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_azure_cli.__dirname + '/lib.npmtest_azure_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/cli.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n// If running from MSI installed version, don't use the\n// compile on the fly streamline files. MSI install precompiles\n// the streamline files\nif (!process.env.PRECOMPILE_STREAMLINE_FILES) {\n  require('streamline').register({ cache: true });\n}\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\n\nvar _ = require('underscore');\nvar callerId = require('caller-id');\n\nvar CmdLoader = require('./cmdLoader');\nvar ExtendedCommand = require('./util/extendedcommand');\nvar log = require('./util/logging');\n\nvar telemetry = require('./util/telemetry');\nvar utilsCore = require('./util/utilsCore');\nvar Interactor = require('./util/interaction');\n\n//'genMode' is only used on generating command metadata, value: 'asm' or 'arm'\nfunction AzureCli(name, parent, genMode) {\n  this.parent = parent;\n  this.output = log;\n  this.interaction = new Interactor(this);\n  AzureCli['super_'].call(this, name);\n\n  if (parent) {\n    this._mode = parent._mode;\n  }\n  else {\n    this.initSetup();\n\n    this.enableNestedCommands(this);\n\n    // Check node.js version.\n    // Do it after changing exception handler.\n    this.checkVersion();\n\n    this._mode = genMode;\n    if (!this._mode) {\n      this._mode = utilsCore.getMode();\n    }\n    var loader = new CmdLoader(this, this._mode);\n    if (genMode) {\n      log.info('Generating command metadata file: ' + loader.cmdMetadataFile);\n      loader.harvestPlugins();\n      loader.harvestModules();\n      loader.saveCmdMetadata();\n      log.info('Done');\n      return;\n    } else if (loader.cmdMetadataExists()) {\n      loader.initFromCmdMetadata(AzureCli);\n    } else {\n      log.warn('No existing command metadata files. Command will run slow.');\n      loader.harvestPlugins();\n      loader.harvestModules();\n    }\n  }\n}\n\nutil.inherits(AzureCli, ExtendedCommand);\n\n_.extend(AzureCli.prototype, {\n  initSetup: function () {\n    var self = this;\n\n    self.debug = process.env.AZURE_DEBUG === '1';\n\n    // Install global unhandled exception handler to make unexpected errors more user-friendly.\n    if (!self.debug && process.listeners('uncaughtException').length === 0) {\n      self.uncaughExceptionHandler = function (err) {\n        self.interaction.clearProgress();\n\n        // Exceptions should always be logged to the console\n        var noConsole = false;\n        if (!log['default'].transports.console) {\n          noConsole = true;\n          self.output.add(self.output.transports.Console);\n        }\n\n        var loggedFullError = false;\n        if (err.message) {\n          log.error(err.message);\n        } else if (err.Message) {\n          log.error(err.Message);\n        } else {\n          log.json('error', err);\n          loggedFullError = true;\n        }\n\n        if (!loggedFullError) {\n          if (err.stack) {\n            log.verbose('stack', err.stack);\n          }\n\n          log.json('silly', err);\n        }\n\n        self.recordError(err);\n\n        if (noConsole) {\n          self.output.remove(self.output.transports.Console);\n        }\n\n        self.exit('error', null, 1);\n      };\n\n      process.addListener('uncaughtException', self.uncaughExceptionHandler);\n    }\n  },\n\n  getErrorFile: function () {\n    return path.join(utilsCore.azureDir(), 'azure.err');\n  },\n\n  recordError: function (err) {\n    if (err) {\n      var self = this;\n      var errorFile = self.getErrorFile();\n      try {\n        var writeFileFunction = process.env.AZURE_CLI_APPEND_LOGS ? fs.appendFileSync : fs.writeFileSync;\n        writeFileFunction(errorFile, (new Date().toISOString()) + ':\\n' +\n            util.inspect(err) + '\\n' + err.stack + '\\n');\n        log.error('Error information has been recorded to ' + errorFile);\n      } catch (err2) {\n        log.warn('Cannot save error information :' + util.inspect(err2));\n      }\n    }\n  },\n\n  exit: function (level, message, exitCode) {\n    var self = this;\n\n    self.interaction.clearProgress();\n    if (message) {\n      log.log(level, message);\n    }\n\n    if (self.uncaughtExceptionHandler) {\n      process.removeListener('uncaughtException', self.uncaughExceptionHandler);\n    }\n\n    self.exitProcess(exitCode);\n  },\n\n  exitProcess: function (exitCode) {\n    //for nice exiting, particularly the winston async logging, we try not to\n    //use \"process.exit()\", unless there's non-zero exit code we must return.  \n    if (exitCode) {\n      process.exit(exitCode);\n    }\n  },\n\n  normalizeAuthorizationError: function (msg) {\n    var regex = /.*The \\'Authorization\\' header is not present or provided in an invalid format.*/ig;\n    if (msg.match(regex)) {\n      msg = 'Certificate based Authentication is not supported in current mode: \\'' + this._mode +\n            '\\'. Please authenticate using an organizational account via \\'azure login\\' command.';\n    }\n    return msg;\n  },\n\n  execute: function (fn) {\n    var self = this;\n\n    return self.action(function () {\n      self.setupCommandOutput();\n      telemetry.currentCommand(self);\n      telemetry.setMode(self.getMode());\n      log.info('Executing command ' + self.fullName().bold);\n\n      try {\n        // Expected arguments + options + callback\n        var argsCount = fn.length <= 1 ? self.args.length + 2 : fn.length;\n        var args = new Array(argsCount);\n\n        var optionIndex = arguments.length - 1;\n        for (var i = 0; i < arguments.length; i++) {\n          if (typeof arguments[i] === 'object') {\n            optionIndex = i;\n            break;\n          }\n        }\n\n        // append with options and callback\n        var options = arguments[optionIndex].optionValues;\n\n        args[args.length - 2] = options;\n        args[args.length - 1] = callback;\n\n        // set option arguments into their positional respective places\n        var freeArguments = 0;\n        for (var j = 0; j < self.args.length; j++) {\n          var optionName = utilsCore.camelcase(self.args[j].name);\n          if (options[optionName]) {\n            args[j] = options[optionName];\n            delete options[optionName];\n          } else if (freeArguments < arguments.length) {\n            args[j] = arguments[freeArguments];\n            freeArguments++;\n          }\n        }\n\n        fn.apply(this, args);\n      } catch (err) {\n        callback(err);\n      }\n\n      function callback(err) {\n        if (err) {\n          // Exceptions should always be logged to the console unless overturned by test run\n          var noConsole = false;\n          if (!process.env.AZURE_NO_ERROR_ON_CONSOLE && !log['default'].transports.console) {\n            noConsole = true;\n            self.output.add(self.output.transports.Console);\n          }\n\n          if (err.message) {\n            log.error(err.message);\n            log.json('silly', err);\n          } else if (err.Message) {\n            if (typeof err.Message === 'object' && typeof err.Message['#'] === 'string') {\n              var innerError;\n              try {\n                innerError = JSON.parse(err.Message['#']);\n              } catch (e) {\n                // empty\n              }\n\n              if (innerError) {\n                if (noConsole) {\n                  self.output.remove(self.output.transports.Console);\n                }\n\n                return callback(innerError);\n              }\n            }\n\n            err.message = self.normalizeAuthorizationError(err.message);\n            log.error(err.Message);\n            log.json('verbose', err);\n          } else {\n            log.error(err);\n          }\n                    \n          telemetry.onError(err, function () { \n            self.recordError(err);\n            if (err.stack) {\n                (self.debug ? log.error : log.verbose)(err.stack);\n            }\n         \n            if (noConsole) {\n                self.output.remove(self.output.transports.Console);\n            }\n            \n            self.exit('error', self.fullName().bold + ' command ' + 'failed\\n'.red.bold, 1);\n          });\n        } else {\n          telemetry.onFinish(function() {\n            self.exit('info', self.fullName().bold + ' command ' + 'OK'.green.bold, 0);\n          });\n        }\n      }\n    });\n  },\n\n  /*\n  * Extends the default parseOptions to support multiple levels in command parsing.\n  */\n  parseOptions: function (argv) {\n    var args = [];\n    var len = argv.length;\n    var literal = false;\n    var option;\n    var arg;\n\n    var unknownOptions = [];\n\n    // parse options\n    for (var i = 0; i < len; ++i) {\n      arg = argv[i];\n\n      // literal args after --\n      if ('--' == arg) {\n        literal = true;\n        continue;\n      }\n\n      if (literal) {\n        args.push(arg);\n        continue;\n      }\n\n      // find matching Option\n      option = this.optionFor(arg);\n\n      //// patch begins\n      var commandOption = null;\n\n      if (!option && arg[0] === '-') {\n        var command = this;\n        var arga = null;\n        for (var a = 0; a < args.length && command && !commandOption; ++a) {\n          arga = args[a];\n          if (command.categories && (arga in command.categories)) {\n            command = command.categories[arga];\n            commandOption = command.optionFor(arg);\n            continue;\n          }\n          break;\n        }\n        if (!commandOption && arga && command && command.commands) {\n          for (var j in command.commands) {\n            if (command.commands[j].name === arga) {\n              commandOption = command.commands[j].optionFor(arg);\n              break;\n            }\n          }\n        }\n      }\n      //// patch ends\n\n      // option is defined\n      if (option) {\n        // requires arg\n        if (option.required) {\n          arg = argv[++i];\n          if (!arg) {\n            return this.optionMissingArgument(option);\n          }\n\n          if ('-' === arg[0]) {\n            return this.optionMissingArgument(option, arg);\n          }\n\n          this.emit(option.name(), arg);\n        } else if (option.optional) {\n          // optional arg\n          arg = argv[i + 1];\n          if (!arg || '-' === arg[0]) {\n            arg = null;\n          } else {\n            ++i;\n          }\n\n          this.emit(option.name(), arg);\n        // bool\n        } else {\n          this.emit(option.name());\n        }\n        continue;\n      }\n\n      // looks like an option\n      if (arg.length > 1 && '-' == arg[0]) {\n        unknownOptions.push(arg);\n\n        // If the next argument looks like it might be\n        // an argument for this option, we pass it on.\n        //// patch: using commandOption if available to detect if the next value is an argument\n        // If it isn't, then it'll simply be ignored\n        commandOption = commandOption || { optional : 1 }; // default assumption\n        if (commandOption.required || (commandOption.optional && argv[i + 1] && '-' != argv[i + 1][0])) {\n          unknownOptions.push(argv[++i]);\n        }\n        continue;\n      }\n\n      // arg\n      args.push(arg);\n    }\n\n    return { args: args, unknown: unknownOptions };\n  },\n\n  setupCommandLogFormat: function (topMost) {\n    if (topMost) {\n      var opts = {\n        json: false,\n        level: 'info'\n      };\n\n      log.format(opts);\n    }\n  },\n\n  setupCommandOutput: function (raw) {\n    var self = this;\n    var verbose = 0;\n    var json = 0;\n\n    if (!raw) {\n      raw = self.normalize(self.parent.rawArgs.slice(2));\n    }\n\n    function hasOption(optionName) {\n      return self.options.some(function (o) { return o.long === optionName; });\n    }\n\n    for (var i = 0, len = raw.length; i < len; ++i) {\n      if (hasOption('--json') && raw[i] === '--json') {\n        ++json;\n      } else if (hasOption('--verbose') &&\n        (raw[i] === '-v' || raw[i] === '--verbose')) {\n        ++verbose;\n      }\n    }\n\n    var opts = { json: false };\n    if (json || verbose) {\n      if (json) {\n        opts.json = true;\n        opts.level = 'data';\n      }\n      if (verbose) {\n        opts.level = (verbose == 1) ? 'verbose' : 'silly';\n      }\n    } else {\n      opts.level = 'info';\n    }\n    log.format(opts);\n  },\n\n  enableNestedCommands: function (command) {\n    if (!command.parent) {\n      command.option('-v, --version', 'output the application version');\n    }\n\n    if (!command.categories) {\n      command.categories = {};\n    }\n\n    command.category = function (name) {\n      var category = command.categories[name];\n      if (!command.categories[name] || (command.categories[name]).stub && this.executingCmd) {\n        category = command.categories[name] = new AzureCli(name, this);\n        command.categories[name].stub = false;\n        category.helpInformation = command.categoryHelpInformation;\n        command.enableNestedCommands(category);\n      }\n\n      return category;\n    };\n\n    command.on('*', function () {\n      var args = command.rawArgs.slice(0, 2);\n      var raw = command.normalize(command.rawArgs.slice(2));\n\n      var category = '*';\n      if (raw.length > 0) {\n        category = raw[0];\n        args = args.concat(raw.slice(1));\n      }\n\n      var i, index;\n      var targetCmd;\n      var cat = command.categories[category];\n      var containsJson = args.some(function (item) { return item === '--json'; });\n      var containsHelp = args.some(function (item) { return (item === '-h' || item === '--help'); });\n      //see whether it is top level command, like 'login', 'logout', etc\n      if (!cat){\n        index = command.searchCommand(category, command.commands);\n        if (index !== -1){\n          targetCmd = require(command.commands[index].filePath);\n          targetCmd.init.apply(command, [command]);\n          //route it through the standard process of displaying help, if the command contains the help option.\n          if (containsHelp) {\n            targetCmd = command.commands[index];\n            return targetCmd.commandHelpInformation(containsJson);\n          }\n          //execute command by emitting event, which will be routed to the handler.\n          return this.parse(command.rawArgs);\n        }\n      }\n\n      //see whether it is a nested command\n      for (i = 2; cat && i < args.length && args[i] !== '-h' && args[i] !== '--help';  i++) {\n        index = command.searchCommand(args[i], cat.commands);\n        if (index !== -1) {\n          targetCmd = cat.commands[index];\n          break;\n        } else {\n          cat = cat.categories[args[i]];\n        }\n      }\n\n      //we have found the command, execute it.\n      if (targetCmd) {\n        //no need to load the command file, as we get help from the metadata file\n        if (i + 1 < args.length) {   \n          if (containsHelp) {\n            return targetCmd.commandHelpInformation(containsJson);\n          }\n        }\n        this.executingCmd = true;\n        if (!this.workaroundOnAsmSiteCommands(targetCmd, command)) {\n          targetCmd = require(targetCmd.filePath);\n          targetCmd.init(command);\n        }\n        cat = command.categories[category];\n        return cat.parse(args);\n      }\n\n      if (!cat) {\n        var toBlame = (i > 2) ? args[i - 1] : category;\n        var longFormCurrentMode = this.getLongFormForMode(this._mode);\n        var otherMode = this.getOtherMode();\n        var longFormOtherMode = this.getLongFormForMode(otherMode);\n        var msg = util.format('\\'%s\\' is not an azure command. See \\'azure help\\'.\\nThe current mode is: %s (%s).', toBlame, this._mode, longFormCurrentMode);\n        msg += util.format('\\nThis *may be* a valid command in \\'%s\\' (%s) mode. \\nUse \\'azure config mode %s\\' to switch mode and then retry the command.', otherMode, longFormOtherMode, otherMode);\n        this.exit('error', msg, 1);\n      } else {\n        //if we are here, then it is about display help.\n        command.categoryHelpInformation.apply(cat,[containsJson]);\n      }\n    });\n  },\n\n  //Contrary to all other commands, ASM\\Site commands were written\n  //differently that loading the single file containing the command\n  //is not enough, due to cross referencing, so we load them all.\n  //For new commands, we will not approve using the style.\n  workaroundOnAsmSiteCommands: function (targetCmd, command) {\n    if (path.basename(targetCmd.filePath).indexOf('site.') !== -1) {\n      var siteCmdDir = path.dirname(targetCmd.filePath);\n      var siteCmdFiles = utilsCore.getFiles(siteCmdDir, false);\n      var filesToLoad = {};\n      var sitePlugins = [];\n\n      //It is possible that ._js and precompiled version (.js) co-exist when\n      //both are laid down by the installer. We should only load .js ones.\n      siteCmdFiles.forEach(function (f) {\n        var basename = path.basename(f);\n        if (basename.indexOf('site.') === 0) {\n          var nameWithoutExt = basename.substring(0, basename.lastIndexOf('.'));\n          var ext = path.extname(basename);\n          if (filesToLoad[nameWithoutExt]) {\n            if (ext === '.js') {\n              filesToLoad[nameWithoutExt] = f;\n            }\n          } else {\n            filesToLoad[nameWithoutExt] = f;\n          }\n        }\n      });\n      Object.keys(filesToLoad).forEach(function (f) {\n        sitePlugins.push(require(filesToLoad[f]));\n      });\n      sitePlugins.forEach(function (plugin) {\n        if (plugin.init) {\n          plugin.init(command);\n        }\n      });\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  command: function (name) {\n    var args = name.split(/ +/);\n    var cmd = new AzureCli(args.shift(), this);\n    cmd.option('-v, --verbose', 'use verbose output');\n    cmd.option('-vv', 'more verbose with debug output');\n    cmd.option('--json', 'use json output');\n\n    var caller = callerId.getData();\n    cmd.filePath = caller.filePath;\n    cmd.helpInformation = cmd.commandHelpInformation;\n    var index = this.searchCommand(cmd.name, this.commands);\n    if (index !== -1) {\n      this.commands[index] = cmd;\n    } else {\n      this.commands.push(cmd);\n    }\n    cmd.parseExpectedArgs(args);\n    return cmd;\n  },\n\n  searchCommand: function(name, commands) {\n    if ( !commands || !name ) return -1;\n    for (var i = 0; i < commands.length; i++) {\n      if (commands[i].name === name) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  deprecatedDescription: function (text, newCommand) {\n    return this.description(util.format('%s (deprecated. This command is deprecated and will be removed in a future version. Please use \\\"%s\\\" instead', text, newCommand));\n  },\n\n  detailedDescription: function (str) {\n    if (0 === arguments.length) return this._detailedDescription;\n    this._detailedDescription = str;\n    return this;\n  },\n\n  getLongFormForMode: function (mode) {\n    return mode === 'arm' ? 'Azure Resource Manager' : 'Azure Service Management';\n  },\n\n  getOtherMode: function () {\n    return this.getMode() === 'arm' ? 'asm' : 'arm';\n  },\n\n  getMode: function () {\n    return this._mode;\n  },\n\n  isAsmMode: function () {\n    return utilsCore.ignoreCaseEquals(this._mode, 'asm');\n  },\n\n  isArmMode: function () {\n    return utilsCore.ignoreCaseEquals(this._mode, 'arm');\n  },\n\n  checkVersion: function () {\n    // Uploading VHD needs 0.6.15 on Windows\n    var version = process.version;\n    var ver = version.split('.');\n    var ver1num = parseInt(ver[1], 10);\n    var ver2num = parseInt(ver[2], 10);\n    if (ver[0] === 'v0') {\n      if (ver1num < 6 || (ver1num === 6 && ver2num < 15)) {\n        throw new Error('You need node.js v0.6.15 or higher to run this code. Your version: ' +\n            version);\n      }\n      if (ver1num === 7 && ver2num <= 7) {\n        throw new Error('You need node.js v0.6.15 or higher to run this code. Your version ' +\n            version + ' won\\'t work either.');\n      }\n    }\n  }\n});\n\nexports = module.exports = AzureCli;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/cmdLoader.js":"﻿/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar fs = require('fs');\nvar path = require('path');\n\nvar utilsCore = require('./util/utilsCore');\n\nfunction CmdLoader(topCmd, mode) {\n  this.topCmd = topCmd;\n  this.cmdMode = mode;\n  this.cmdMetadataFile = path.join(__dirname, 'plugins.' + this.cmdMode  + '.json');\n  this.cmdBasePath = __dirname;\n}\n\n_.extend(CmdLoader.prototype, {\n  harvestPlugins: function (topLevelOnly) {\n    var self = this;\n    var plugins = this._loadCmdsFromFolder(path.join(this.cmdBasePath, 'commands'), false);\n    plugins.forEach(function (plugin) { plugin.init(self.topCmd); });\n    \n    if (!topLevelOnly) {\n      // Load mode specific plugins\n      var modePlugins = this._loadCmdsFromFolder(path.join(this.cmdBasePath, 'commands', this.cmdMode), true);\n      modePlugins.forEach(function (plugin) { plugin.init(self.topCmd); });\n    }\n  },\n  \n  harvestModules: function () {\n    var self = this;\n    \n    var basePath = path.dirname(__filename);\n    \n    var walkPath = path.join(basePath, '../node_modules');\n    var harvestPaths = [walkPath];\n    \n    while (path.basename(walkPath) === 'node_modules' && path.dirname(walkPath) !== 'npm') {\n      var nextPath = path.join(walkPath, '../..');\n      if (nextPath === walkPath) {\n        break;\n      }\n      harvestPaths.push(nextPath);\n      walkPath = nextPath;\n    }\n    \n    var modules = [];\n    harvestPaths.forEach(function (harvestPath) {\n      modules = modules.concat(self._loadCmdsFromNodeModules(harvestPath));\n    });\n    \n    modules.forEach(function (module) {\n      module.plugin.init(self.topCmd);\n    });\n  },\n  \n  initFromCmdMetadata: function (AzureCli) {\n    var self = this;\n    var initCategory = function (category, parent) {\n      function process(entity, entityParent) {\n        var newEntity = new AzureCli(entity.name, entityParent);\n        \n        if (entity.description) {\n          newEntity._description = entity.description;\n        }\n        \n        //TODO, for some fields, we create wrapper functions here,\n        //so that existing code won't break. We should get rid of them soon.\n        newEntity.description = function () {\n          return newEntity._description;\n        };\n\n        newEntity.fullName = function () {\n          return entity.fullName;\n        };\n        \n        newEntity._usage = entity.usage;\n        newEntity.usage = function () {\n          return newEntity._usage;\n        };\n\n        newEntity.filePath = entity.filePath ? \n          path.resolve(self.cmdBasePath, entity.filePath) : entity.filePath;\n        newEntity.stub = true;\n        \n        if (entity.options) {\n          for (var o in entity.options) {\n            newEntity.option(entity.options[o].flags, entity.options[o].description);\n          }\n        }\n        \n        return newEntity;\n      }\n      \n\n      var newCategory = category;\n      //can't invoke \"process\" for top category, which would new  \n      //up a top AzureCli and get us into an infinite loop. \n      if (parent) {\n        newCategory = process(category, parent);\n      }\n\n      for (var i = 0 ; i < category.commands.length; i++) {\n        newCategory.commands[i] = (process(category.commands[i], newCategory));\n      }\n      \n      if (!newCategory.categories) {\n        newCategory.categories = {};\n      }\n      \n      for (var j in category.categories) {\n        newCategory.categories[j] = initCategory(category.categories[j], newCategory);\n      }\n      \n      return newCategory;\n    };\n\n    var data = fs.readFileSync(this.cmdMetadataFile);\n    var cachedPlugins = JSON.parse(data);\n    var plugins = initCategory(cachedPlugins);\n    \n    this.topCmd.commands = plugins.commands;\n    this.topCmd.categories = plugins.categories;\n  },\n  \n  saveCmdMetadata: function () {\n    var metadate = this._serializeCategory(this.topCmd);\n    fs.writeFileSync(this.cmdMetadataFile, JSON.stringify(metadate, null, 2));\n  },\n  \n  cmdMetadataExists: function () {\n    return utilsCore.pathExistsSync(this.cmdMetadataFile);\n  },\n\n  _loadCmdsFromFolder: function (scanPath, recursively) {\n    var results = utilsCore.getFiles(scanPath, recursively);\n    \n    results = results.filter(function (filePath) {\n      var extname = path.extname(filePath);\n      if (filePath.substring(0, 5) === 'tmp--') {\n        return false;\n      } else if (extname !== '.js' && extname !== '._js') {\n        //Skip unrelated/temp files\n        return false;\n      }\n      return true;\n    });\n    \n    if (process.env.PRECOMPILE_STREAMLINE_FILES) {\n      results = results.filter(function (filePath) {\n        if (filePath.substring(filePath.length - 4) === '._js') {\n          return false;\n        }\n        return true;\n      });\n    }\n    \n    // sort them so they load in a predictable order\n    results = results.sort();\n    \n    // skip directories\n    results = results.filter(function (filePath) {\n      return fs.statSync(filePath).isFile();\n    });\n    \n    // load modules\n    results = results.map(function (filePath) {\n      return require(filePath);\n    });\n    \n    // look for exports.init\n    results = results.filter(function (entry) {\n      return entry.init !== undefined;\n    });\n    return results;\n  },\n  \n  _loadCmdsFromNodeModules: function (scanPath) {\n    var results = fs.readdirSync(scanPath);\n    \n    results = results.map(function (moduleName) {\n      return {\n        moduleName: moduleName,\n        modulePath: path.join(scanPath, moduleName)\n      };\n    });\n    \n    results = results.filter(function (item) {\n      try {\n        item.moduleStat = fs.statSync(item.modulePath);\n      } catch (error) {\n        return false;\n      }\n      return item.moduleStat.isDirectory();\n    });\n    \n    results = results.filter(function (item) {\n      item.packagePath = path.join(item.modulePath, 'package.json');\n      item.packageStat = utilsCore.pathExistsSync(item.packagePath) ? fs.statSync(item.packagePath) : undefined;\n      return item.packageStat && item.packageStat.isFile();\n    });\n    \n    results = results.filter(function (item) {\n      try {\n        item.packageInfo = JSON.parse(fs.readFileSync(item.packagePath));\n        return item.packageInfo && item.packageInfo.plugins && item.packageInfo.plugins['azure-cli'];\n      }\n        catch (err) {\n        return false;\n      }\n    });\n    \n    results = this._flatten(results.map(function (item) {\n      var plugins = item.packageInfo.plugins['azure-cli'];\n      if (!_.isArray(plugins)) {\n        plugins = [plugins];\n      }\n      \n      return plugins.map(function (relativePath) {\n        return {\n          context: item,\n          pluginPath: path.join(item.modulePath, relativePath)\n        };\n      });\n    }));\n    \n    results = results.filter(function (item) {\n      item.plugin = require(item.pluginPath);\n      return item.plugin.init;\n    });\n    \n    return results;\n  },\n  \n  _flatten: function (arrays) {\n    var result = [];\n    arrays.forEach(function (array) {\n      result = result.concat(array);\n    });\n    return result;\n  },\n  \n  _serializeIndividualEntity: function (entity) {\n    //TODO: split out the concept of category or command\n    var cmdOrCat = {};\n    \n    if (entity.name) {\n      cmdOrCat.name = entity.name;\n    }\n    \n    if (entity.description) {\n      cmdOrCat.description = entity.description();\n    }\n    \n    if (entity.fullName) {\n      cmdOrCat.fullName = entity.fullName();\n    }\n    \n    if (entity.usage) {\n      cmdOrCat.usage = entity.usage();\n    }\n    \n    if (entity.filePath) {\n      //Normalize the file path, so that it can be used for both linux and windows.\n      cmdOrCat.filePath = path.relative(this.cmdBasePath, entity.filePath).split('\\\\').join('/');\n    }\n    \n    if (entity.options) {\n      cmdOrCat.options = entity.options;\n    }\n    \n    return cmdOrCat;\n  },\n  \n  _serializeCategory: function (category) {\n    var cat = this._serializeIndividualEntity(category);\n    cat.commands = [];\n    cat.categories = {};\n    \n    if (category.commands) {\n      for (var i in category.commands) {\n        cat.commands.push(this._serializeIndividualEntity(category.commands[i]));\n      }\n    }\n    \n    if (category.categories) {\n      for (var j in category.categories) {\n        var currentCategory = this._serializeCategory(category.categories[j]);\n        cat.categories[currentCategory.name] = currentCategory;\n      }\n    }\n    \n    return cat;\n  }\n\n});\n\nmodule.exports = CmdLoader;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/utilsCore.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar _ = require('underscore');\nvar fs = require('fs');\nvar path = require('path');\nvar read = require('read');\nvar wrap = require('wordwrap').hard(0, 75);\nvar util = require('util');\nvar Constants = require('./constants');\nvar userHome = require('user-home');\n\nexports.camelcase = function (flag) {\n  return flag.split('-').reduce(function (str, word) {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n};\n\nexports.ignoreCaseEquals = function (a, b) {\n  return a === b ||\n    (a !== null && a !== undefined &&\n    b !== null && b !== undefined &&\n    (a.toLowerCase() === b.toLowerCase())) === true;\n};\n\nexports.azureDir = function () {\n  if (!process.env.AZURE_CONFIG_DIR && !userHome) {\n    throw new Error('No Azure_CONFIG_DIR or HOME path is available');\n  }\n  var dir = process.env.AZURE_CONFIG_DIR ||\n    path.join(userHome, '.azure');\n  if (!exports.pathExistsSync(dir)) {\n    fs.mkdirSync(dir, 502); // 0766\n  }\n\n  return dir;\n};\n\nexports.stringStartsWith = function (text, prefix, ignoreCase) {\n  if (_.isNull(prefix)) {\n    return true;\n  }\n  \n  if (ignoreCase) {\n    return text.toLowerCase().substr(0, prefix.toLowerCase().length) === prefix.toLowerCase();\n  } else {\n    return text.substr(0, prefix.length) === prefix;\n  }\n};\n\nexports.pathExistsSync = fs.existsSync ? fs.existsSync : path.existsSync;\n\n/**\n * Read azure cli config\n */\nexports.readConfig = function () {\n  var azureConfigPath = path.join(exports.azureDir(), 'config.json');\n  \n  var cfg = {};\n  \n  if (exports.pathExistsSync(azureConfigPath)) {\n    try {\n      cfg = JSON.parse(fs.readFileSync(azureConfigPath));\n    } catch (err) {\n      cfg = {};\n    }\n  }\n  \n  return cfg;\n};\n\nexports.writeConfig = function (cfg) {\n  var azurePath = exports.azureDir();\n  var azureConfigPath = path.join(exports.azureDir(), 'config.json');\n  \n  if (!exports.pathExistsSync(azurePath)) {\n    fs.mkdirSync(azurePath, 502); //0766\n  }\n  \n  fs.writeFileSync(azureConfigPath, JSON.stringify(cfg, null, 2));\n};\n\nexports.getMode = function () {\n  var config = exports.readConfig();\n  return config.mode ? config.mode : Constants.API_VERSIONS.ARM;\n};\n\nexports.getFiles = function (scanPath, recursively) {\n  var results = [];\n\n  var list = fs.readdirSync(scanPath);\n\n  var pending = list.length;\n  if (!pending) {\n    return results;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var file = list[i];\n\n    file = scanPath + '/' + file;\n\n    var stat = fs.statSync(file);\n    if (stat && stat.isDirectory()) {\n      if (recursively) {\n        var res = exports.getFiles(file);\n        results = results.concat(res);\n      }\n    } else {\n      results.push(file);\n    }\n  }\n\n  return results;\n};\n\nexports.readTelemetry = function () {\n  var azureTelemetryPath = path.join(exports.azureDir(), Constants.TELEMETRY);\n  \n  var telemetry = {};\n  \n  if (exports.pathExistsSync(azureTelemetryPath)) {\n    try {\n      telemetry = JSON.parse(fs.readFileSync(azureTelemetryPath));\n    } catch (err) {\n      telemetry = {};\n    }\n  }\n  \n  return telemetry;\n};\n\nexports.writeTelemetry = function (telemetry) {\n  var azurePath = exports.azureDir();\n  var azureTelemetryPath = path.join(exports.azureDir(), Constants.TELEMETRY);\n  \n  if (!exports.pathExistsSync(azurePath)) {\n    fs.mkdirSync(azurePath, 502); //0766\n  }\n  \n  fs.writeFileSync(azureTelemetryPath, JSON.stringify(telemetry, null, 2));\n};\n\n/**\n * Determines whether telemtry is enabled or not. If this is the first time, that this decision \n * needs to be made, then it prompts the user for data collection. It will timeout in 60 seconds \n * with default response being 'n' i.e. telemetry is disabled.\n *\n * @returns {function} callback(err, result)\n *\n *                      {null}    err      - Always null.\n *\n *                      {boolean} result   - true if telemetry is enabled, false otherwise.\n */\nexports.isTelemetryEnabled = function (callback) {\n  var telemetryInfo = exports.readTelemetry();\n  var outcome = false;\n  if (telemetryInfo.telemetry !== null && telemetryInfo.telemetry !== undefined && typeof telemetryInfo.telemetry === 'boolean') {\n    return callback(null, telemetryInfo.telemetry);\n  } else if (process.argv[2] && process.argv[2].toLowerCase() === 'telemetry') {\n    return callback(null, outcome);\n  } else {\n    // we've determined that this is not a telemetry command and we do not have user's telemetry preference.\n    // we proceed to read out the telemetry prompt and get user preference. But, before that check if we're\n    // in non interactive mode. If so, do not prompt, assume default response of 'no'.\n    // This behavior is intended to make scripting scenarios better. E.g: running azure cli on a CI server.\n    if (process.env['AZURE_NON_INTERACTIVE_MODE']) {\n      return callback(null, outcome);\n    }\n\n    var telemetryPromptText = wrap('\\nMicrosoft Azure CLI would like to collect data about how users use CLI commands and some problems they encounter.  ' + \n      'Microsoft uses this information to improve our CLI commands.  Participation is voluntary and when you choose to participate your device ' + \n      'automatically sends information to Microsoft about how you use Azure CLI. ' + \n      '\\n\\nIf you choose to participate, you can stop at any time later by using Azure CLI as follows: ' +\n      '\\n1.  Use the azure telemetry command to turn the feature Off. ' +\n      '\\nTo disable data collection, execute: azure telemetry --disable' +\n      '\\n\\nIf you choose to not participate, you can enable at any time later by using Azure CLI as follows: ' +\n      '\\n1.  Use the azure telemetry command to turn the feature On. ' +\n      '\\nTo enable data collection, execute: azure telemetry --enable' +\n      '\\n\\nSelect y to enable data collection :(y/n) ');\n    \n    var telemetryOptions = {\n      prompt : telemetryPromptText,\n      timeout : 30000,\n      edit : false,\n      silent : false\n    };\n\n    read(telemetryOptions, function(err, result) {\n      if ((err && err.message === 'timed out') || (result && result.match(/^no?$/i))) {\n        exports.writeTelemetry({telemetry: false});\n        console.log('\\nYou choose not to participate in Microsoft Azure CLI data collection.\\n\\n');\n      } else if (result && result.match(/^y?(es)?$/i)) {\n        exports.writeTelemetry({telemetry: true});\n        outcome = true;\n        console.log('\\nYou choose to participate in Microsoft Azure CLI data collection.\\n\\n');\n      } else {\n        exports.writeTelemetry({telemetry: false});\n        console.log(wrap(util.format('\\nYou provided \\'%s\\' which is an invalid input. This translates ' + \n          'to you choosing not to participate in Microsoft Azure CLI data collection.\\n\\n', result)));\n      }\n      return callback(null, outcome);\n    });\n  }\n};","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/constants.js":"﻿//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nexports = module.exports;\n\nvar Constants = {\n  API_VERSIONS: {\n    ASM: 'asm',\n    ARM: 'arm'\n  },\n\n  /**\n  * Constant default http port.\n  *\n  * @const\n  * @type {string}\n  */\n  DEFAULT_HTTP_PORT: 80,\n\n  /**\n  * Constant default https port.\n  *\n  * @const\n  * @type {string}\n  */\n  DEFAULT_HTTPS_PORT: 443,\n\n  /**\n  * Constant client ID used by the CLI\n  *\n  * @const\n  * @type {string}\n  */\n  XPLAT_CLI_CLIENT_ID: '04b07795-8ddb-461a-bbee-02f9e1bf7b46',\n\n  /**\n  * Constant xml2js 1.0 metadata marker.\n  *\n  * @const\n  * @type {string}\n  */\n  XML_METADATA_MARKER: '@',\n\n  /**\n  * Constant xml2js 1.0 value marker.\n  *\n  * @const\n  * @type {string}\n  */\n  XML_VALUE_MARKER: '#',\n\n  /**\n  * Constant max file size allowed for custom data.\n  *\n  * @const\n  * @type {integer}\n  */\n  CUSTOM_DATA_FILE_SIZE: 65535,\n\n  Namespaces: {\n    Arrays: 'http://schemas.microsoft.com/2003/10/Serialization/Arrays',\n    WindowsAzure: 'http://schemas.microsoft.com/windowsazure',\n    XMLSchema: 'http://www.w3.org/2001/XMLSchema-instance'\n  },\n\n  AAD_COMMON_TENANT: 'common',\n\n  /**\n  * Constant telemetry config file name.\n  *\n  * @const\n  * @type {string}\n  */\n  TELEMETRY: 'telemetry.json',\n\n  /**\n  * Constant instrumentation key used by telemetry.\n  *\n  * @const\n  * @type {string}\n  */\n  TELEMETRY_INSTRUMENTATION_KEY: '218959e7-a213-4923-a22b-d8b001062f28',\n\n  USER_AGENT: 'user-agent',\n\n  XMS_COMMAND_NAME: 'x-ms-command-name',\n  XMS_PARAMETER_SET_NAME: 'x-ms-parameter-set-name'\n};\n\nmodule.exports = Constants;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/extendedcommand.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n//\n// Extensions to Commander to support nested commands / help system\n//\nvar _ = require('underscore');\nvar commander = require('commander');\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar utilsCore = require('./utilsCore');\nvar pjson = require('../../package.json');\nvar Constants = require('./constants');\n\nfunction ExtendedCommand(name) {\n  ExtendedCommand['super_'].call(this, name);\n}\n\nutil.inherits(ExtendedCommand, commander.Command);\n\n_.extend(ExtendedCommand.prototype, {\n\n  //////////////////////////////\n  // override help subsystem\n\n  fullName: function () {\n    var name = this.name;\n    var scan = this.parent;\n    while (scan && scan.parent !== undefined) {\n      name = scan.name ? scan.name + ' ' + name : name;\n      scan = scan.parent;\n    }\n\n    return name;\n  },\n\n  usage: function (str) {\n    var ret;\n\n    if (str) {\n      ret = commander.Command.prototype.usage.call(this, str);\n    } else {\n      ret = commander.Command.prototype.usage.call(this);\n      ret = ret.replace(/,/g,' ');\n    }\n\n    return ret;\n  },\n\n  helpInformation: function() {\n    var self = this;\n\n    if (!self.parent) {\n      var raw = self.normalize(process.argv.slice(2));\n      var containsJson = raw.some(function (item) { return item === '--json'; });\n      if (containsJson) {\n        self.output.format({ json: true, level: 'data' });\n        self.output.json(self.helpJSON());\n        return '';\n      }\n      var packagePath = path.join(__dirname, '../../package.json');\n      var packageInfo = JSON.parse(fs.readFileSync(packagePath));\n\n      if (raw.indexOf('-v') >= 0) {\n        console.log(packageInfo.version);\n      } else if (raw.indexOf('--version') >= 0) {\n        console.log(util.format('%s (node: %s)', packageInfo.version, process.versions.node));\n      } else {\n        self.setupCommandLogFormat(true);\n\n        self.output.info('         _    _____   _ ___ ___'.cyan);\n        self.output.info('        /_\\\\  |_  / | | | _ \\\\ __|'.cyan);\n        self.output.info('  _ ___'.grey + '/ _ \\\\'.cyan + '__'.grey + '/ /| |_| |   / _|'.cyan + '___ _ _'.grey);\n        self.output.info('(___  '.grey + '/_/ \\\\_\\\\/___|\\\\___/|_|_\\\\___|'.cyan + ' _____)'.grey);\n        self.output.info('   (_______ _ _)         _ ______ _)_ _ '.grey);\n        self.output.info('          (______________ _ )   (___ _ _)'.grey);\n        self.output.info('');\n\n        self.output.info('Microsoft Azure: Microsoft\\'s Cloud Platform');\n        self.output.info('');\n        self.output.info('Tool version', packageInfo.version);\n\n        self.helpCommands();\n        self.helpCategoriesSummary(self.showMore());\n        self.helpOptions();\n        self.showCommandMode();\n      }\n    } else {\n      self.output.help(self.description());\n      self.output.help('');\n      self.output.help('Usage:', self.fullName() + ' ' + self.usage());\n      self.helpOptions();\n      self.showCommandMode();\n    }\n\n    return '';\n  },\n\n  showCommandMode: function(){\n    this.output.help('');\n    var mode = this._mode;\n    if (!mode) {\n      mode = utilsCore.getMode();\n    }\n    var text = util.format('Current Mode: %s (Azure %s Management)', mode, \n      (mode === Constants.API_VERSIONS.ASM ? 'Service' : 'Resource')); \n    this.output.help(text);\n  },\n\n  showMore: function () {\n    var raw = this.normalize(process.argv.slice(2));\n    return raw.indexOf('--help') >= 0 || raw.indexOf('-h') >= 0;\n  },\n\n  categoryHelpInformation: function(containsJson) {\n    var self = this;\n    if (containsJson) {\n      var result = self.getJSONMetadata(true);\n      if (!result) {\n        throw new Error(util.format('Unable to provide help in JSON format for \\'%s\\'', self.fullName()));\n      }\n      self.output.format({ json: true, level: 'data' });\n      return self.output.json(result);\n    }\n    this.output.help(self.description());\n    \n    if (this.name === 'vm' || this.name === 'vmss' || this.name === 'acs' || this.name === 'managed-disk' || this.name === 'managed-snapshot' || this.name === 'managed-image') {\n      self.helpComputeCategories(-1, 0, this.name);\n      self.helpCommands();\n    } else {\n      self.helpCommands();\n      self.helpCategories(-1);\n    }\n\n    self.helpOptions();\n    self.showCommandMode();\n    return '';\n  },\n\n  commandHelpInformation: function(containsJson) {\n    var self = this;\n    if (containsJson) {\n      var result = self.getJSONMetadata(false);\n      if (!result) {\n        throw new Error(util.format('Unable to provide help in JSON format for \\'%s\\'', self.fullName()));\n      }\n      self.output.format({ json: true, level: 'data' });\n      return self.output.json(result);\n    }\n    if (self._detailedDescription) {\n      this.output.help(self.detailedDescription());\n    } else {\n      this.output.help(self.description());\n    }\n\n    this.output.help('');\n    this.output.help('Usage:', self.fullName() + ' ' + self.usage());\n\n    self.helpOptions();\n    self.showCommandMode();\n\n    return '';\n  },\n\n  helpJSON: function() {\n    var self = this;\n    var result = _.tap({}, function(res){\n      if(_.isNull(self.parent) || _.isUndefined(self.parent)){\n        res.name = pjson.name;\n        res.description = pjson.description;\n        res.author = pjson.author;\n        res.version = pjson.version;\n        res.contributors = pjson.contributors;\n        res.homepage = pjson.homepage;\n        res.licenses = pjson.licenses;\n      } else {\n        res.name = self.fullName();\n        res.description = self.description();\n      }\n      res.usage = self.usage();\n    });\n\n    if (this.categories && Object.keys(this.categories).length > 0) {\n      result.categories = {};\n\n      for (var name in this.categories) {\n        result.categories[name] = this.categories[name].helpJSON();\n      }\n    }\n\n    if (this.commands && this.commands.length > 0) {\n      result.commands = [];\n\n      this.commands.forEach(function (cmd) {\n        var command = {\n          name: cmd.fullName(),\n          description: cmd.description(),\n          options: cmd.options,\n          usage: cmd.usage()\n        };\n\n        result.commands.push(command);\n      });\n    }\n\n    return result;\n  },\n\n  helpCategories: function(levels) {\n    for (var name in this.categories) {\n      var cat = this.categories[name];\n\n      this.output.help('');\n\n      this.output.help(cat.description().cyan);\n\n      if (levels === -1 || levels > 0) {\n        for (var index in cat.commands) {\n          var cmd = cat.commands[index];\n          this.output.help(' ', cmd.fullName() + ' ' + cmd.usage());\n        }\n\n        cat.helpCategories(levels !== -1 ? --levels : -1);\n      } else {\n        this.output.help(' ', cat.fullName());\n      }\n    }\n  },\n\n  helpComputeCategories: function(levels, depth, catName) {\n    for (var name in this.categories) {\n      var cat = this.categories[name];\n      if (depth === 0) {\n        this.output.help('');\n        this.output.help(cat.description().cyan);\n      }\n\n      if (levels === -1 || levels > 0) {\n        // Compress command names only for 'vmss config' category, i.e.\n        // 'vmss config sku set' & 'vmss config sku delete' =>\n        // 'vmss config sku set|delete'\n        var index = 0;\n        var cmd = null;\n        if (depth >= 1 && utilsCore.stringStartsWith(cat.fullName(), catName + ' config ')) {\n          var commandNames = [];\n          for (index in cat.commands) {\n            cmd = cat.commands[index];\n            commandNames.push(cmd.name);\n          }\n          this.output.help(' ', cat.fullName() + ' ' + commandNames.join('|') + ' [options]');\n        }\n        else {\n          for (index in cat.commands) {\n            cmd = cat.commands[index];\n            this.output.help(' ', cmd.fullName() + ' ' + cmd.usage());\n          }\n        }\n\n        cat.helpComputeCategories(levels !== -1 ? --levels : -1, depth + 1, catName);\n      } else {\n        this.output.help(' ', cat.fullName());\n      }\n    }\n  },\n\n  helpCategoriesSummary: function(showMore) {\n    var self = this;\n    var categories = [];\n    function scan(parent, levels, each) {\n      for (var name in parent.categories) {\n        var cat = parent.categories[name];\n\n        each(cat);\n\n        if (levels === -1 || levels > 0) {\n          scan(cat, levels !== -1 ? --levels : -1, each);\n        }\n      }\n    }\n\n    scan(this, showMore ? -1 : 0, function (cat) { categories.push(cat); });\n    var maxLength = 14;\n\n    // Sort categories by alphabetical order\n    categories.sort(function (a, b) {\n      return (a.fullName() <  b.fullName()) ? -1 : (a.fullName() >  b.fullName()) ? 1 : 0;\n    });\n\n    categories.forEach(function (cat) {\n      if (maxLength < cat.fullName().length)\n        maxLength = cat.fullName().length;\n    });\n\n    self.output.help('');\n    self.output.help('Commands:');\n    categories.forEach(function (cat) {\n      var name = cat.fullName();\n      while (name.length < maxLength) {\n        name += ' ';\n      }\n\n      self.output.help('  ' + name + ' ' + cat.description().cyan);\n    });\n  },\n\n  helpCommands: function() {\n    var self = this;\n\n    this.commands.forEach(function (cmd) {\n      self.output.help('');\n      self.output.help(cmd.description().cyan);\n      self.output.help(' ', cmd.fullName() + ' ' + cmd.usage());\n    });\n  },\n\n  helpOptions: function() {\n    var self = this;\n    self.output.help('');\n    self.output.help('Options:');\n    self.optionHelp().split('\\n').forEach(function (line) { self.output.help(' ', line); });\n  },\n  \n  //enable the flag for auto-complete to list files under \n  //current working directory\n  fileRelatedOption: function (flags, description) {\n    this.option(flags, description);\n    this.options[this.options.length - 1].fileRelatedOption = true;\n    return this;\n  },\n\n  option: function (flags, description, fn, defaultValue) {\n    var self = this;\n\n    var option = new commander.Option(flags, description);\n\n    // Remove preexistant option with same name\n    self.options = self.options.filter(function (o) {\n      return o.name() !== option.name() || o.long !== option.long;\n    });\n\n    var oname = option.name();\n    var name = utilsCore.camelcase(oname);\n\n    if (!self.optionValues) {\n      self.optionValues = {};\n    }\n\n    // default as 3rd arg\n    if ('function' !== typeof fn) {\n      defaultValue = fn;\n      fn = null;\n    }\n\n    // preassign default value only for --no-*, [optional], or <required>\n    if (false === option.bool || option.optional || option.required) {\n      // when --no-* we make sure default is true\n      if (false === option.bool) defaultValue = true;\n      // preassign only if we have a default\n      if (undefined !== defaultValue) self.optionValues[name] = defaultValue;\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // when it's passed assign the value\n    // and conditionally invoke the callback\n    this.on(oname, function (val) {\n      // coercion\n      if (val && fn) val = fn(val);\n\n      // unassigned or bool\n      if ('boolean' === typeof self.optionValues[name] || 'undefined' === typeof self.optionValues[name]) {\n        // if no value, bool true, and we have a default, then use it!\n        if (!val) {\n          self.optionValues[name] = option.bool ? defaultValue || true : false;\n        } else {\n          self.optionValues[name] = val;\n        }\n      } else if (val) {\n        // reassign\n        self.optionValues[name] = val;\n      }\n    });\n\n    return this;\n  },\n\n  getJSONMetadata: function (isCategoryHelp) {\n    //Local function\n    function findItem(arr, item) {\n      var filteredArray = arr.filter(function (element) {\n        if (element.name === item) {\n          return element;\n        }\n      });\n      return filteredArray[0];\n    }\n    //Actual function definition\n    var self = this;\n    var cmdMetadatafile = path.join(__dirname, '..', 'plugins.' + utilsCore.getMode() + '.json');\n    var data = fs.readFileSync(cmdMetadatafile);\n    var jsonInfo = {};\n    try {\n      jsonInfo = JSON.parse(data);\n    } catch (err) {\n      throw new Error(util.format('Error occurred while parsing the json file \\'%s\\': \\n%s', \n        cmdMetadatafile, util.inspect(err, { depth: null })));\n    }\n    \n    var categories = jsonInfo.categories;\n    var cmdLookup = self.fullName().trim().split(' ');\n    var cats = cmdLookup;\n    var command = '';\n    if (!isCategoryHelp) {\n      command = cmdLookup[cmdLookup.length - 1];\n      var topCmd = findItem(jsonInfo.commands, command);\n      if (topCmd) return topCmd;\n      cats = cmdLookup.slice(0, cmdLookup.length - 1);\n    }\n\n    for (var i = 0; i< cats.length; i++) {\n      if (categories[cats[i]]) {\n        if (i === cats.length - 1) {\n          categories = categories[cats[i]];\n        } else {\n          categories = categories[cats[i]].categories;\n        } \n      }\n    }\n\n    if (!isCategoryHelp) {\n      return findItem(categories.commands, command);\n    } else {\n      return categories;\n    }\n  }\n});\n\nmodule.exports = ExtendedCommand;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/logging.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n//\n// Logging infrastructure for the xplat CLI\n//\n\nvar log = require('winston');\nvar eyes = require('eyes');\nvar os = require('os');\nvar Table = require('easy-table');\nvar util = require('util');\nvar wrap = require('wordwrap');\nvar path = require('path');\n\nvar utilsCore = require('./utilsCore');\n\n// use cli output settings by default\nlog.cli();\n\nlog.add(log.transports.File, {\n  name: 'silly',\n  filename: path.join(utilsCore.azureDir(), 'azure.details.log'),\n  level: 'silly',\n  json: false,\n  colorize:false,\n  padlevel: false,\n  timestamp: false,\n  stripColors: true,\n  silent: process.env.AZURE_CLI_DISABLE_LOG_CAPTURE,\n  options: { flags: 'w' },\n  formatter: function (options) {\n    var code = /\\u001b\\[(\\d+(;\\d+)*)?m/g;\n    var msg = (undefined !== options.message ? options.message.replace(code, '') : '');\n    return options.level + ': '+ msg +\n          (options.meta && Object.keys(options.meta).length ? '\\n' + JSON.stringify(options.meta, null, 2) : '');\n  }\n});\n\nvar jsonMode;\n\nlog.format = function (options) {\n  var consoleTransport = log['default'].transports['console'];\n  var testTransport = log['default'].transports['memory'];\n  if (consoleTransport && testTransport) { \n    throw new Error('Internal error: both console and memory transports are specified.');\n  }\n  var defaultTransport = consoleTransport || testTransport;\n  if (!defaultTransport) {\n    throw new Error('Internal error: missing winston transport.');\n  }\n  defaultTransport.colorize = process.stdout.isTTY;\n  if (arguments.length === 0) {\n    return {\n      json: jsonMode,\n      level: defaultTransport.level,\n    };\n  }\n\n  if (options.json) {\n    log.padLevels = false;\n    log.stripColors = true;\n    jsonMode = true;\n    defaultTransport.formatter = function (options) {\n      if (options.meta && Object.keys(options.meta).length || !options.message) {\n        return options.meta ? JSON.stringify(options.meta, null, 2) : '';\n      } else if (options.message) {\n        return options.level + ': ' + options.message.replace(/\\x1b\\[[0-9]+m/g, '');\n      }\n    };\n    //do not set 'json' flags on transport, as winston makes unfavorable assumption \n    //such as deep clone of the \"meta\" field which complicates the json object.\n  } else {\n    log.padLevels = true;\n    log.stripColors = false;\n    jsonMode = false;\n    defaultTransport.formatter = null;\n  }\n  if (options.level) {\n    defaultTransport.level = options.level;\n  }\n};\n\nlog.json = function (level, data) {\n  if (arguments.length == 1) {\n    data = level;\n    level = 'data';\n  }\n\n  if (log.format().json) {\n    if (!data) {\n      log.log(level, '');\n    } else {\n      log.log(level, '', data);\n    }\n  } else {\n    var lines = eyes.inspect(data, level, { stream: false });\n    lines.split('\\n').forEach(function (line) {\n      // eyes all is \"cyan\" by default, so this property accessor will\n      // fix the entry/exit color codes of the line. it's needed because we're\n      // splitting the eyes formatting and inserting winston formatting where it\n      // wasn't before.\n      log.log(level, line[eyes.defaults.styles.all]);\n    });\n  }\n};\n\nlog.table = function (level, data, transform) {\n  if (arguments.length == 2) {\n    transform = data;\n    data = level;\n    level = 'data';\n  }\n\n  if (log.format().json) {\n    log.log(level, 'table', data);\n  } else {\n    var table = new Table();\n    table.LeftPadder = Table.LeftPadder;\n    table.padLeft = Table.padLeft;\n    table.RightPadder = Table.RightPadder;\n    table.padRight = Table.padRight;\n\n    if (data && data.forEach) {\n      data.forEach(function (item) { transform(table, item); table.newLine(); });\n    } else if (data) {\n      for (var item in data) {\n        transform(table, item);\n        table.newLine();\n      }\n    }\n\n    for (var i in table.lines) {\n      for (var column in table.columns) {\n        if (!table.lines[i].hasOwnProperty(column)) {\n          table.lines[i][column] = '';\n        }\n      }\n    }\n\n    var lines = table.toString();\n    lines.substring(0, lines.length - 1).split('\\n').forEach(function (line) {\n      log.log(level, line);\n    });\n  }\n};\n\nlog.nameValue = function (name, value, indent, displayNullValue) {\n  var delimiter = ': ';\n  if (!displayNullValue) displayNullValue = false;\n  if (!indent) indent = 0;\n  var key = spaces(indent) + name;\n  key += spaces(32 - key.length);\n\n  if (value !== undefined && value !== null) {\n    log.data(key + delimiter + value);\n  } else if (displayNullValue) {\n    log.data(key + delimiter + '\"\"');\n  }\n};\n\nlog.header = function (header, indent, newLine) {\n  var delimiter = ':';\n  if (newLine) {\n    log.data('');\n  }\n  log.data(spaces(indent) + header + delimiter);\n};\n\nlog.list = function (items, indent, newLine) {\n  items.forEach(function (item) {\n    log.listItem(item, indent, newLine);\n  });\n};\n\nlog.listItem = function (item, indent, newLine) {\n  if (newLine) {\n    log.data('');\n  }\n  log.data(spaces(indent) + item);\n};\n\n/**\n * This overrides original winston warn function to work properly within --json option\n */\nvar originalWarn = log.warn;\nlog.warn = function() {\n  if (!log.format().json) {\n    originalWarn.apply(this, arguments);\n  }\n};\n\nfunction getProperty(value, propertyName) {\n  if (typeof value === 'undefined' || value === null) {\n    return '';\n  }\n\n  if (!propertyName) {\n    return value;\n  }\n\n  var first = propertyName.split('.')[0];\n  var rest = propertyName.slice(first.length + 1);\n  return getProperty(value[first], rest);\n}\n\nfunction spaces(num) {\n  if (num > 0) {\n    return new Array(num + 1).join(' ');\n  }\n  return '';\n}\n\nfunction toWidth(string, width) {\n  var pad = width - string.length;\n  return string + spaces(pad);\n}\n\nfunction defaultFormat(data) {\n  if (typeof data === 'undefined' || data === null) {\n    return '';\n  }\n  if (data instanceof Array) {\n    if (data.length === 0) {\n      return '[]';\n    }\n    return data.join(', ');\n  }\n\n  return data.toString();\n}\n\nfunction doReport(indentation, reportFormat, data, outfn) {\n  if (reportFormat.length === 0) {\n    return;\n  }\n\n  var maxWidth = 80;\n  if (process.stdout.isTTY) {\n    maxWidth = process.stdout.columns;\n  }\n\n  var headerWidth = Math.max.apply(null,\n    reportFormat.map(function (item) { return item[0].length; })\n    ) + 2;\n\n  reportFormat.forEach(function (item) {\n    var title = item[0] + ':';\n    var field = item[1];\n    var formatter = item[2] || defaultFormat;\n\n    var value = getProperty(data, field);\n    if (formatter instanceof Array) {\n      outfn(spaces(indentation) + toWidth(title, headerWidth));\n      doReport(indentation + headerWidth, formatter, value, outfn);\n    } else {\n      var leftIndentation = 'verbose: '.length + indentation + headerWidth;\n      var formatted = wrap.hard(leftIndentation, maxWidth)(formatter(value));\n      formatted = spaces(indentation) + toWidth(title, headerWidth) +\n        formatted.slice(leftIndentation);\n      outfn(formatted);\n    }\n  });\n}\n\nlog.report = function (reportFormat, data) {\n  if (log.format().json) {\n    log.log('data', 'table', data);\n  } else {\n    doReport(0, reportFormat, data, log.data.bind(log));\n  }\n};\n\nlog.report.allProperties = function (data) {\n  if (typeof data === 'undefined' || data === null || data === '') {\n    return '[]';\n  }\n  var subreport = Object.keys(data).map(function (key) {\n    return [key, key];\n  });\n  var result = [];\n  doReport(0, subreport, data, function (o) { result.push(o); });\n  result.push('');\n  return result.join(os.EOL);\n};\n\nlog.report.asDate = function (data) {\n  return new Date(Date.parse(data)).toString();\n};\n\nlog.report.inspect = function (data) {\n  return util.inspect(data, {depth: null});\n};\n\nlog.createLogFilter = function () {\n  return function handle(resource, next, callback) {\n    log.silly('requestOptions');\n    try {\n      var loggedResource = JSON.parse(JSON.stringify(resource));\n      if (loggedResource.headers && loggedResource.headers.Authorization) {\n        delete loggedResource.headers.Authorization;\n      }\n      if (loggedResource.body && \n          (loggedResource.body.length > 2 * 1024 * 1024 || loggedResource.body.type === 'Buffer')) { // if the body is large, log only that the body was too large to log and was more than likely file content\n        loggedResource.body = 'REQUEST BODY DATA OMMITTED FROM LOG DUE TO SIZE';\n      }\n      log.json('silly', loggedResource);\n    } catch (error) {\n      return callback (error);\n    }\n    return next(resource, function (err, response, body) {\n      log.silly('returnObject');\n      if (response) {\n        var bodyToLog = body;\n        if (body && (body.length > 2 * 1024 * 1024 || body.type === 'Buffer')) { // if the body is large, log only that the body was too large to log and was more than likely file content\n          bodyToLog = 'RESPONSE BODY DATA OMMITTED FROM LOG DUE TO SIZE';\n        }\n        log.json('silly', {\n          statusCode: response.statusCode,\n          header: response.headers,\n          body: bodyToLog\n        });\n      }\n\n      callback(err, response, body);\n    });\n  };\n};\nlog.spaces = spaces;\n\nmodule.exports = log;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/telemetry.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar os = require('os');\nvar fs = require('fs');\nvar crypto = require('crypto');\nvar _appInsights = require('applicationinsights');\nvar profile = require('./profile');\nvar utilsCore = require('./utilsCore');\nvar Constants = require('./constants');\nvar userAgentCore = require('./userAgentCore');\n\nvar _event;\nvar _isEnabled = false;\nvar _currentCommand;\nvar _rawCommand;\nvar _subscription;\n\nvar _Data = (function () {\n  var Data = function () {\n  };\n  return Data;\n})();\n\nvar _PageViewData = (function () {\n  var PageViewData = function () {\n    this.ver = 2;\n    this.properties = {};\n    this.measurements = {};\n  };\n  return PageViewData;\n})();\n\nvar _AzureCliQosEvent = function () {\n  return {\n    startTime: Date.now(),\n    duration: 0,\n    isSuccess: true,\n    commandName: '',\n    command: '',\n    mode: '', // arm or asm\n    nodeVersion: '',\n    userId: '',\n    userType: '',\n    installationType: 'NONE', //NONE, INSTALLER or NPM\n    osType: os && os.type(),\n    osVersion: os && os.release()\n  };\n};\n\nvar _getInstallationType = function (command) {\n  var type = 'NONE';\n  var osType = os.type();\n  if (osType === 'Windows_NT') {\n    if (command) {\n      type = command.indexOf('Microsoft SDKs\\\\Azure') > -1 ? 'INSTALLER' : 'NPM';\n    }\n  } else if (osType === 'Darwin') {\n    try {\n      // If azure-cli is installed using npm, '/usr/local/bin/azure' is a symbolic link to node_modules\n      // If installed by installer, '/usr/local/bin/azure' is an executable file instead.\n      var lstat = fs.lstatSync('/usr/local/bin/azure');\n      type = lstat.isSymbolicLink() ? 'NPM' : 'INSTALLER';\n    } catch (e) {\n      // Not able to figure out installation type.\n    }\n  } else {\n    // On Linux, no installer provided currently.\n    type = 'NPM';\n  }\n  return type;\n};\n\nvar _getCurrentSubscription = function () {\n  var thumbprint = function (cert) {\n    if (!cert) {\n      // default value\n      return 'none';\n    }\n    return crypto.createHash('sha1')\n      .update(new Buffer(cert, 'base64').toString('binary'))\n      .digest('hex');\n  };\n\n  var subscription = {\n    id: 'none',\n    user: {\n      id: 'none',\n      type: 'none'\n    }\n  };\n\n  var sub;\n  try {\n    sub = profile.current.getSubscription();\n  } catch (e) {\n\n  }\n\n  if (sub) {\n    subscription.id = sub.id;\n    if (sub.user) {\n      subscription.user.id = crypto.createHash('sha256').update(sub.user.name).digest('hex');\n      subscription.user.type = sub.user.type;\n    } else if (sub.managementCertificate) {\n      subscription.user.id = thumbprint(sub.managementCertificate.cert);\n      subscription.user.type = 'managementCertificate';\n    }\n  }\n  return subscription;\n};\n\nvar _filterCommand = function (commandName, rawCommand) {\n  var outCmd = '';\n  if (rawCommand && commandName) {\n    outCmd = commandName;\n    // Starting from 3rd argv is the command\n    var filterStartIndex = 2 + outCmd.split(/\\s+/).length;\n    for (var i = filterStartIndex; i < rawCommand.length; i++) {\n      var token = rawCommand[i];\n      if (!utilsCore.stringStartsWith(token, '-')) {\n        token = (token.length > 40) ? '***' : token.replace(/./g, '*');\n      }\n      outCmd += ' ' + token;\n    }\n  }\n  return outCmd;\n};\n\nvar _stop = function (qosEvent) {\n  if (qosEvent) {\n    qosEvent.duration = Date.now() - qosEvent.startTime;\n  }\n};\n\n// helper for Application Insights\nvar _msToTimeSpan = function (totalms) {\n  if (isNaN(totalms) || totalms < 0) {\n    totalms = 0;\n  }\n  var ms = '' + totalms % 1000;\n  var sec = '' + Math.floor(totalms / 1000) % 60;\n  var min = '' + Math.floor(totalms / (1000 * 60)) % 60;\n  var hour = '' + Math.floor(totalms / (1000 * 60 * 60)) % 24;\n  ms = ms.length === 1 ? '00' + ms : ms.length === 2 ? '0' + ms : ms;\n  sec = sec.length < 2 ? '0' + sec : sec;\n  min = min.length < 2 ? '0' + min : min;\n  hour = hour.length < 2 ? '0' + hour : hour;\n  return hour + ':' + min + ':' + sec + '.' + ms;\n};\n\nvar _trackPageView = function (data) {\n  var pageView = new _PageViewData();\n  pageView.name = data.commandName;\n  if (!isNaN(data.duration)) {\n    pageView.duration = _msToTimeSpan(data.duration);\n  }\n  pageView.properties = data;\n  var _data = new _Data();\n  _data.baseType = 'PageViewData';\n  _data.baseData = pageView;\n  _appInsights.client.track(_data);\n};\n\nvar _flush = function (callback) {\n  if (_isEnabled) {\n    _appInsights.client.sendPendingData(callback);\n  }\n};\n\nvar _stripUsername = function (str) {\n  if (str) {\n    var re = /(.*users[\\\\|\\/])(.*?)([\\\\|\\/].*)/gi;\n    return str.replace(re, '$1***$3');\n  } else {\n    return str;\n  }\n};\n\n/*\n* initialize app insights telemetry only if telemetry is\n* enabled by the end user. But do populate common info which is\n* required to construct user agent string for request headers.\n*/\nexports.init = function (isEnabled) {\n  _isEnabled = isEnabled;\n  _subscription = _getCurrentSubscription();\n\n  if (_isEnabled) {\n    _appInsights.setup(Constants.TELEMETRY_INSTRUMENTATION_KEY)\n      .setAutoCollectRequests(false)\n      .setAutoCollectPerformance(false)\n      .setAutoCollectExceptions(false);\n\n    // Overwrite appinsight default values.\n    var context = _appInsights.client.context;\n    context.tags[context.keys.userId] = _subscription.user.id;\n\n    _appInsights.start();\n  }\n};\n\nexports.currentCommand = function (command) {\n  if (command && typeof command === 'object') {\n    _currentCommand = command;\n\n    if (_event) {\n      _event.commandName = command.fullName();\n      _event.command = _filterCommand(_event.commandName, _rawCommand);\n\n      // update user agent info about the current command\n      userAgentCore.setCommandInfo(_event.commandName, _filterCommand(' ', _rawCommand));\n    }\n  }\n};\n\n/*\n* populate command info and system diagnostics. This data is common\n* to app insights telemetry and user agent string that goes into the request headers.\n*/\nexports.start = function (command) {\n  if (command) {\n    _rawCommand = command;\n  }\n\n  _event = _AzureCliQosEvent();\n  _event.installationType = _getInstallationType(command);\n  _event.nodeVersion = process.version;\n  _event['Azure.Subscription.Id'] = _subscription.id;\n  _event.userId = _subscription.user.id;\n  _event.userType = _subscription.user.type;\n\n  var macAddressHash = _getMacAddressHash();\n  if (macAddressHash) {\n    _event.macAddressHash = macAddressHash;\n  }\n\n  // set user agent information.\n  userAgentCore.setUserAgentData(constructUserAgentData());\n};\n\nexports.setAppInsights = function (appInsights) {\n  _appInsights = appInsights;\n};\n\nexports.setMode = function (mode) {\n  if (_event) {\n    _event.mode = mode;\n\n    // update user agent info.\n    userAgentCore.setMode(mode);\n  }\n};\n\nexports.onError = function (err, callback) {\n  if (_isEnabled && _event) {\n    _stop(_event);\n    _event.isSuccess = false;\n    _event.stacktrace = _stripUsername(err.stack);\n    _event.errorCategory = err.statusCode ? 'HTTP_Error_' + err.statusCode : 'CLI_Error';\n    _appInsights.client.trackEvent('CmdletError', _event);\n    _flush(callback);\n  } else {\n    callback();\n  }\n};\n\n/*\n* report telemetry only if it is enabled.\n*/\nexports.onFinish = function (callback) {\n  if (_isEnabled && _event) {\n    _stop(_event);\n    _trackPageView(_event);\n    _flush(callback);\n  } else {\n    callback();\n  }\n};\n\n/*\n* construct user agent info for request header.\n*/\nfunction constructUserAgentData() {\n  if (_event) {\n    return {\n      osType: _event.osType,\n      osVersion: _event.osVersion,\n      nodeVersion: _event.nodeVersion,\n      installationType: _event.installationType,\n      userId: _event.userId,\n      subscriptionId: _event['Azure.Subscription.Id'],\n      userType: _event.userType,\n      macAddressHash: _event.macAddressHash ? _event.macAddressHash : ''\n    };\n  }\n}\n\n\nvar _getMacAddressHash = function () {\n  var networkInterfaces, macAddressHash, macAddress;\n\n  try {\n    networkInterfaces = os.networkInterfaces();\n    var interfaceKeys = Object.keys(networkInterfaces);\n\n    var nicPattern;\n    if (os.platform().startsWith('win')) {\n      nicPattern = /ethernet/i;\n    } else {\n      nicPattern = /en[0-9]/i;\n    }\n\n    var index = interfaceKeys.findIndex(function (intf) {\n      return nicPattern.test(intf);\n    });\n\n    if (index < 0) {\n      // didnt find a group named `ethernet` or `en[0-1]`. \n      // iterate through all interfaces and get the first one that has a valid mac.\n      macAddress = _getMacOfFirstInterface(networkInterfaces);\n    } else {\n      // if we found a `ethernet` or `en[0-1]` group, then just get the `mac` from the group.\n      // This cannot be invalid as this would have been set by the NIC's manufacturer.\n      var interfaceGroup = networkInterfaces[interfaceKeys[index]];\n      macAddress = interfaceGroup[0].mac;\n    }\n  } catch (err) {\n    //On win10 bash currently os.networkInterfaces() throws an error. Thus we catch the error and \n    // do nothing about it. For such scenarios we do not send the hashed mac address.\n  }\n\n  if (macAddress) {\n    macAddressHash = crypto.createHash('sha256').update(macAddress).digest('hex');\n  }\n\n  return macAddressHash;\n};\n\nvar _getMacOfFirstInterface = function (interfaces) {\n  var nic;\n  var validMacPattern = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;\n  var skipPattern = /^(0{2}[:-]){5}(0{2})$/;\n  for (var key in interfaces) {\n    if (interfaces.hasOwnProperty(key)) {\n      nic = interfaces[key];\n\n      var index = nic.findIndex(function (n) {\n        return validMacPattern.test(n.mac) && !skipPattern.test(n.mac);\n      });\n\n      if (index >= 0) {\n        return nic[index].mac;\n      }\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/profile/index.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar profile = require('./profile');\n\n//\n// Consolidation file so that users can import this directory as a single module\n//\n\nmodule.exports = profile;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/profile/profile.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\n\nvar adalAuth = require('../authentication/adalAuth');\nvar Environment = require('./environment');\nvar Subscription = require('./subscription');\nvar publishSettings = require('./publishSettings');\nvar cacheUtils = require('../cacheUtils');\nvar log = require('../logging');\nvar utils = require('../utils');\nvar $ = utils.getLocaleString;\n\n//\n// Profile object - this manages the serialization of environment\n// and subscription data for the current user.\n//\n\nfunction Profile() {\n  var self = this;\n  self.environments = {};\n  Environment.publicEnvironments.forEach(function (env) {\n    self.addEnvironment(env);\n  });\n  self.subscriptions = {};\n\n  self.onSubscriptionUpdated = this.save.bind(this);\n}\n\nObject.defineProperty(Profile.prototype, 'currentSubscription', {\n  enumerable: true,\n  get: function () {\n    return _.chain(this.subscriptions)\n      .values()\n      .filter(function (s) { return s.isDefault; })\n      .first()\n      .value() || null;\n  },\n\n  set: function (value) {\n    _.values(this.subscriptions)\n      .forEach(function (s) { s.isDefault = false; });\n    if (value) {\n      value.isDefault = true;\n    }\n  }\n});\n\n_.extend(Profile.prototype, {\n  addEnvironment: function (env) {\n    this.environments[env.name] = env;\n  },\n\n  getDefaultEnvironment: function () {\n    return this.environments[Environment.DEFAULT_ENV_NAME];\n  },\n\n  getEnvironment: function (envName) {\n    if (!envName) {\n      return this.environments.AzureCloud;\n    }\n    var key = _.keys(this.environments)\n      .filter(function (env) { return utils.ignoreCaseEquals(env, envName); })[0];\n    return this.environments[key];\n  },\n\n  deleteEnvironment: function (environmentOrName) {\n    if (_.isString(environmentOrName)) {\n      delete this.environments[environmentOrName];\n    } else {\n      delete this.environments[environmentOrName.name];\n    }\n  },\n  \n  //Never use this method as the naming is rather misleading.\n  //Use \"addOrUpdateSubscription\" instead. This method is only\n  //used by test framework in generated nock records.\n  addSubscription: function (subscription) {\n    this.addOrUpdateSubscription(subscription);\n  },\n\n  addOrUpdateSubscription: function (subscription) {\n    var existingSubscription = _.values(this.subscriptions)\n      .filter(function (s) { return s.id === subscription.id; })[0];\n\n    if (existingSubscription) {\n      existingSubscription.removeListener('updated', this.onSubscriptionUpdated);\n\n      if (subscription.id!== existingSubscription.id || \n        subscription.tenantId !== existingSubscription.tenantId) {\n        delete this.subscriptions[existingSubscription.id];\n      }\n\n      existingSubscription.updateFrom(subscription);\n      subscription = existingSubscription;\n    }\n\n    this.subscriptions[subscription.id] = subscription;\n    subscription.on('updated', this.onSubscriptionUpdated);\n  },\n\n  deleteSubscription: function (subscriptionId) {\n    var subscription = subscriptionId;\n    if (_.isString(subscriptionId)) {\n      subscription = this.subscriptions[subscriptionId];\n    }\n\n    if (subscription.isDefault) {\n      var remainingSubscriptions = _.values(this.subscriptions)\n        .filter(function (sub) { return sub.id !== subscription.id; });\n      if (_.first(remainingSubscriptions)) {\n        remainingSubscriptions[0].isDefault = true;\n      }\n    }\n\n    subscription.removeListener('updated', this.onSubscriptionUpdated);\n    delete this.subscriptions[subscription.id];\n  },\n\n  logoutUser: function (username, done) {\n    var self = this;\n    username = adalAuth.normalizeUserName(username);\n\n    // Helper functions to define process of logout\n    function usernameMatches(subscription) {\n      var user = subscription.user;\n      return user && utils.ignoreCaseEquals(user.name, username);\n    }\n\n    function defaultGoesLast(subscription) {\n      return subscription.isDefault ? 1 : 0;\n    }\n\n    function removeTokenOrSubscription(subscription) {\n      if (subscription.user) {\n        if (subscription.managementCertificate) {\n          delete subscription.user;\n        } else {\n          self.deleteSubscription(subscription.id);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    function subscriptionsWereRemoved(wasRemoved) {\n      return wasRemoved;\n    }\n\n    // First, delete cached access tokens\n    adalAuth.removeCachedToken(username, function (err) {\n      var loggedOut = _.chain(_.values(self.subscriptions))\n      .filter(usernameMatches)\n      .sortBy(defaultGoesLast)\n      .map(removeTokenOrSubscription)\n      .any(subscriptionsWereRemoved)\n      .value();\n      done(err, loggedOut);\n    });\n  },\n\n  getSubscription: function (idOrName, returnAllMatched) {\n    var subscriptions = [];\n    if (!idOrName) {\n      subscriptions.push(this.currentSubscription);\n      if (!this.currentSubscription) {\n        throw new Error($('There is no current subscription. Please use the azure login command to set your current subscription.'));\n      }\n    } else {\n      //First try to get the subscription from this.subscriptions object where subscriptions are keyed on id.\n      //If there is no exact match by Id then we should try to find a subscription matching on name.\n      if (this.subscriptions[idOrName]) {\n        subscriptions.push(this.subscriptions[idOrName]);\n      } else {\n        subscriptions = _.values(this.subscriptions).filter(function (s) { return utils.ignoreCaseEquals(s.name, idOrName); });\n      }\n\n      if (subscriptions.length === 0) {\n        throw new Error(util.format(\n          $('The subscription \\'%s\\' was not found. Please check your spelling, or use the azure login command to set your subscription.'),\n          idOrName));\n      }\n    }\n    if (returnAllMatched) {\n      return subscriptions;\n    }\n\n    return subscriptions[0];\n  },\n\n  importPublishSettings: function (fileName) {\n    var self = this;\n    _.each(publishSettings.import(fileName), function (subData) {\n      var newSubscription = new Subscription(subData, self._findEnvironment(subData));\n      self.addOrUpdateSubscription(newSubscription);\n      if (!self.currentSubscription) {\n        newSubscription.isDefault = true;\n      }\n    });\n  },\n\n  saveToStream: function (stream) {\n    stream.write(JSON.stringify(this._getSaveData(), null, 4), 'utf8');\n    stream.end();\n  },\n\n  save: function (fileName) {\n    if (!fileName) {\n      fileName = defaultProfileFile;\n    }\n\n    fs.writeFileSync(fileName, JSON.stringify(this._getSaveData(), null, 4), {'mode': '0600'});\n  },\n\n  _getSaveData: function () {\n    return {\n      environments: _.values(this.environments)\n        .filter(function (e) { return !e.isPublicEnvironment; })\n        .map(function (e) { return e.toJSON(); }),\n      subscriptions: _.values(this.subscriptions).map(function (s) { return s.toJSON(); })\n    };\n  },\n\n  /**\n  * Find an environment with a matching management endpoint\n  * @param {object} subscriptionData subscription data from publishsettings file\n  *\n  * @returns corresponding environment object or throws if not found.\n  */\n  _findEnvironment: function (subscriptionData) {\n    var trimmedEndpoint = utils.stringTrimEnd(subscriptionData.managementEndpointUrl, '/');\n\n    var found = _.values(this.environments).filter(function (e) {\n      return utils.ignoreCaseEquals(trimmedEndpoint, utils.stringTrimEnd(e.managementEndpointUrl, '/'));\n    });\n    if (found.length === 0) {\n      throw new Error(util.format(\n        $('Could not find an environment with management endpoint %s. Create one and import this publishSettings file again.'),\n        subscriptionData.managementEndpointUrl));\n    }\n    return found[0];\n  }\n});\n\n//\n// Profile loading functions\n//\n\nfunction load(fileNameOrData) {\n  var profile = new Profile();\n  if (_.isUndefined(fileNameOrData) || fileNameOrData === defaultProfileFile) {\n    return loadDefaultProfile(profile);\n  } else if (_.isString(fileNameOrData)) {\n    return loadProfileFromFile(profile, fileNameOrData);\n  } else {\n    return loadProfileFromObject(profile, fileNameOrData);\n  }\n}\n\nfunction loadDefaultProfile(profile) {\n  profile.fileName = defaultProfileFile;\n  if (utils.pathExistsSync(defaultProfileFile)) {\n    return loadProfileFromFile(profile, defaultProfileFile);\n  }\n  return profile;\n}\n\nfunction loadProfileFromFile(profile, fileName) {\n  profile.fileName = fileName;\n  if (!utils.pathExistsSync(fileName)) {\n    throw new Error(util.format($('Profile file %s does not exist'), fileName));\n  }\n  return loadProfileFromObject(profile, JSON.parse(utils.stripBOM(fs.readFileSync(fileName, 'utf8'))));\n}\n\nfunction loadProfileFromObject(profile, data) {\n  if (data.environments) {\n    data.environments.forEach(function (envData) {\n      var e = new Environment(envData);\n      profile.addEnvironment(e);\n    });\n  }\n  if (data.subscriptions) {\n    data.subscriptions.forEach(function (subData) {\n      profile.addOrUpdateSubscription(new Subscription(subData, profile.environments[subData.environmentName]));\n    });\n    if(!profile.currentSubscription && data.subscriptions.length > 0) {\n      profile.getSubscription(data.subscriptions[0].id).isDefault = true;\n    }\n  }\n  return profile;\n}\n\nfunction clearAzureDir() {\n  function deleteIfExists(file, isDir) {\n    if (utils.pathExistsSync(file)) {\n      log.silly(util.format($('Removing %s'), file));\n      (isDir ? fs.rmdirSync : fs.unlinkSync)(file);\n      return true;\n    } else {\n      log.silly(util.format($('%s does not exist'), file));\n    }\n  }\n\n  var azureDirectory = utils.azureDir();\n  var pemPath = path.join(azureDirectory, 'managementCertificate.pem');\n  var publishSettingsFilePath = path.join(azureDirectory, 'publishSettings.xml');\n\n  var isDeleted = deleteIfExists(pemPath);\n  isDeleted = deleteIfExists(publishSettingsFilePath) || isDeleted; // in this order only\n  isDeleted = cacheUtils.clear() || isDeleted;\n  isDeleted = deleteIfExists(defaultProfileFile) || isDeleted;\n  isDeleted = deleteIfExists(adalAuth.defaultTokenCacheFile) || isDeleted;\n  \n  //the folder might still contain some files such as \"plugin.json\",\n  //we leave them there, since they have nothing to do with account management. \n\n  log.info(isDeleted ? $('Account settings cleared successfully')\n      : $('Account settings are already clear'));\n}\n\nvar defaultProfileFile = path.join(utils.azureDir(), 'azureProfile.json');\n\nvar currentProfile = load(defaultProfileFile);\n\n//\n// Resource management\n//\nfunction toLowerCase(s) { return s.toLowerCase(); }\n\n_.extend(module.exports, {\n  load: load,\n  defaultProfileFile: defaultProfileFile,\n  Profile: Profile,\n  Subscription: Subscription,\n  Environment: Environment,\n  current: currentProfile,\n  clearAzureDir: clearAzureDir,\n  getSubscription: function (subscription) {\n    return currentProfile.getSubscription(subscription);\n  },\n  providerKeyTransform: toLowerCase\n});\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/authentication/adalAuth.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar os = require('os');\nvar path = require('path');\n\nvar async = require('async');\nvar _ = require('underscore');\nvar adal = require('adal-node');\n\nvar utils = require('../utils');\nvar defaultTokenCacheFile = path.join(utils.azureDir(), 'accessTokens.json');\n\nvar useSecureTokenStorage = process.env['AZURE_USE_SECURE_TOKEN_STORAGE']; \nvar TokenStorage;\nif (useSecureTokenStorage && os.platform() === 'darwin') {\n  TokenStorage = require('./osx-token-storage');\n} else if (useSecureTokenStorage && os.platform() === 'win32') {\n  TokenStorage = require('./win-token-storage');\n} else {\n  TokenStorage = require('./file-token-storage');\n}\nvar TokenCache = require('./token-cache');\n\nvar logging = require('../logging');\n\nfunction turnOnLogging() {\n  var log = adal.Logging;\n  log.setLoggingOptions(\n    {\n      level : log.LOGGING_LEVEL.VERBOSE,\n      log : function (level, message, error) {\n        logging.info(message);\n        if (error) {\n          logging.error(error);\n        }\n      }\n    });\n}\n\nif (process.env['AZURE_ADAL_LOGGING_ENABLED']) {\n  turnOnLogging();\n}\n\n//\n// A list of known azure test endpoints for Active Directory.\n// Turn off authority verification if authority is one of these.\n//\nvar knownTestEndpoints = [\n  'https://login.windows-ppe.net',\n  'https://sts.login.windows-int.net'\n];\n\nfunction isKnownTestEndpoint(authorityUrl) {\n  return _.some(knownTestEndpoints, function (endpoint) {\n    return utils.ignoreCaseEquals(endpoint, authorityUrl);\n  });\n}\n\n\n// Add the '.onmicrosoft.com' suffix to the user name if no present\nfunction normalizeUserName(username) {\n  var match = username.match(/^([^@]+@)([^.]+)$/);\n  if (match !== null) {\n    username = match[1] + match[2] + '.onmicrosoft.com';\n  }\n  return username;\n}\n\nfunction createAuthenticationContext(authConfig) {\n  var authorityUrl = authConfig.authorityUrl + '/' + authConfig.tenantId;\n  var validateAuthority = !isKnownTestEndpoint(authConfig.authorityUrl);\n  \n  return new adal.AuthenticationContext(authorityUrl, validateAuthority, exports.tokenCache);\n}\n\nfunction removeCachedToken(username, cache, done) {\n  if (typeof cache === 'function') {\n    done = cache;\n    cache = exports.tokenCache;\n  }\n  var entriesToRemove = [];\n  //To simplify the code, do clean up regardless of the user type.\n  //Because cached token only loads once, the perf hit is minimum.\n  async.each(\n    [{ userId: username }, { _clientId: username }, { servicePrincipalId: username }],\n    function (query, cb) {\n      cache.find(query, function (err, found) {\n        if (err) return cb(err);\n        entriesToRemove = entriesToRemove.concat(found);\n        cb(null);\n      });\n    },\n    function (err) {\n      if (err) return done(err);\n      cache.remove(entriesToRemove, done);\n    });\n}\n\n_.extend(exports, {\n  defaultTokenCacheFile: defaultTokenCacheFile,\n  tokenCache: new TokenCache(new TokenStorage(defaultTokenCacheFile)),\n  createAuthenticationContext: createAuthenticationContext,\n  normalizeUserName: normalizeUserName,\n  removeCachedToken: removeCachedToken\n});\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/utils.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar path = require('path');\nvar url = require('url');\nvar util = require('util');\nvar uuid = require('uuid');\n\nvar azureCommon = require('azure-common');\nvar _ = require('underscore');\n\nvar blobUtils = require('./blobUtils');\nvar constants = require('./constants');\nvar log = require('./logging');\nvar utilsCore = require('./utilsCore');\nvar userAgentCore = require('./userAgentCore');\nvar commandMetadataFilter = require('./commandMetadataFilter');\nvar cliUserAgentFilter = require('./cliUserAgentFilter');\n\nvar locale = require('../locales/en-us.json');\n\nvar BEGIN_CERT = '-----BEGIN CERTIFICATE-----';\nvar END_CERT = '-----END CERTIFICATE-----';\n\nexports.POLL_REQUEST_INTERVAL = 1000;\n\nvar moduleVersion = require('../../package.json').version;\n\nexports.moduleVersion = moduleVersion;\n\nexports.azureDir = utilsCore.azureDir;\nexports.camelcase = utilsCore.camelcase;\nexports.ignoreCaseEquals = utilsCore.ignoreCaseEquals;\nexports.stringStartsWith = utilsCore.stringStartsWith;\nexports.pathExistsSync = utilsCore.pathExistsSync;\n\nvar getUserAgent = exports.getUserAgent = function () {\n  var userAgent = util.format('AzureXplatCLI/%s', moduleVersion);\n  // if this env var is set, then use that in User Agent header\n  if (process.env.AZURE_HTTP_USER_AGENT) {\n    userAgent += ';' + process.env.AZURE_HTTP_USER_AGENT;\n  }\n  else {\n    // else, construct our custom User Agent header.\n    // add OS and command info into the user agent.\n    // Note: Do this only if the above env variable is *not set*.\n    var _userAgentInfo = userAgentCore.getUserAgentData();\n    if (_userAgentInfo) {\n      userAgent += ';' + Object.keys(_userAgentInfo).map(function (key) {\n        return key + ':' + _userAgentInfo[key];\n      }).join(';');\n    }\n  }\n\n  return userAgent;\n};\n\nexports.createClient = function (factoryMethod, credentials, endpoint, options) {\n  if(!options) {\n    options = {};\n  }\n  \n  var client = factoryMethod(credentials,\n    exports.stringTrimEnd(endpoint, '/'))\n    .withFilter(exports.certAuthFilter(credentials))\n    .withFilter(cliUserAgentFilter.create(exports.getUserAgent()))\n    .withFilter(exports.createPostBodyFilter())\n    .withFilter(polishErrorCausedByArmProviderNotRegistered())\n    .withFilter(commandMetadataFilter.create(userAgentCore.getCommandData()));\n  \n  if(!options.disableAutoRedirect) {\n    client = client.withFilter(exports.createFollowRedirectFilter());\n  }\n  \n  if(!options.disableLogFilter) {\n    client = client.withFilter(log.createLogFilter());\n  }\n  \n  return client;\n};\n\n/**\n * Create Autorest client\n * @param {function} Method to create an instance of the client\n * @param {object} Subscription object\n * @param {object} [options] - Optional parameters\n * @param {boolean} [options.isTenantBased] - A Boolean value (true) indicating that the client is tenant based\n * @param {string} [options.endPoint] - The url specifying the endpoint (baseUrl) for the client\n */\n\nexports.createAutoRestClient = function (FactoryMethod, subscription, options) {\n  ensureAADBackedSubscription(subscription);\n  var credentials = null;\n  var baseUri = null;\n  var subscriptionOrTenantId = null;\n\n  if (options && options.isTenantBased && options.isTenantBased === true) {\n    if (!options.endPoint) {\n      options.endPoint = subscription.resourceManagerEndpointUrl;\n    }\n    subscriptionOrTenantId = subscription.tenantId;\n    credentials = subscription._createCredentials(options.endPoint);\n    baseUri = exports.stringTrimEnd(options.endPoint, '/');\n  } else {\n    subscriptionOrTenantId = subscription.id;\n    credentials = subscription._createCredentials();\n    baseUri = exports.stringTrimEnd(subscription.resourceManagerEndpointUrl, '/');\n  }\n\n  var factoryMethodOptions = {};\n  factoryMethodOptions.filters = [\n    exports.certAuthFilter(credentials),\n    log.createLogFilter(),\n    cliUserAgentFilter.create(exports.getUserAgent()),\n    exports.createPostBodyFilter(),\n    exports.createFollowRedirectFilter(),\n    polishErrorCausedByArmProviderNotRegistered(),\n    commandMetadataFilter.create(userAgentCore.getCommandData())\n  ];\n  \n  // there are a subset of clients that do not require a subscription\n  // TODO: need to figure out a way to pass options into factoryMethodOptions.\n  if (options && options.noSubscription) {\n    if (options.requiresBaseUri) {\n      return new FactoryMethod(credentials, baseUri, factoryMethodOptions);\n    } else {\n     return new FactoryMethod(credentials, factoryMethodOptions);\n    }\n  } else {  \n    return new FactoryMethod(credentials, subscriptionOrTenantId, baseUri, factoryMethodOptions);\n    }\n};\n\nfunction _createAsmClient(factoryMethod, subscription) {\n  return exports.createClient(factoryMethod,\n    subscription._createCredentials(),\n    subscription.managementEndpointUrl);\n}\n\nfunction _createArmClient(factoryMethod, subscription, options) {\n  ensureAADBackedSubscription(subscription);\n  if(!options) {\n    options = {};\n  }\n  \n  if(!options.endpoint) {\n    options.endpoint = subscription.resourceManagerEndpointUrl;\n  }\n  \n  return exports.createClient(factoryMethod,\n    subscription._createCredentials(),\n    options.endpoint,\n    options);\n}\n\nfunction ensureAADBackedSubscription(subscription) {\n  if (subscription.wasCreatedFromPublishSettingsFile()) {\n    throw new Error('The current cmdlet requires you to log in using Azure Active Directory account, ' + \n      'not from a .publishsettings file. Please run \\'azure login\\' or use \\'azure account set\\' ' + \n      'to select a correct subscription.');\n  }\n}\n\nexports.getHDInsightClusterManagementClient = function (cloudServiceName, subscription) {\n  var factoryMethod = require('azure-asm-hdinsight').createHDInsightClusterManagementClient;\n  var client = _createAsmClient(factoryMethod, subscription);\n  client.cloudServiceName = cloudServiceName;\n  return client;\n};\n\nexports.getHDInsightCluster2ManagementClient = function (cloudServiceName, subscription) {\n  var factoryMethod = require('azure-asm-hdinsight').createHDInsightCluster2ManagementClient;\n  var client = _createAsmClient(factoryMethod, subscription);\n  client.cloudServiceName = cloudServiceName;\n  return client;\n};\n\nexports.getHDInsightJobManagementClient = function (clusterDnsName, userName, password) {\n  var hdinsight = require('azure-asm-hdinsight');\n  var client = hdinsight.createHDInsightJobManagementClient(clusterDnsName,\n    new hdinsight.createBasicAuthenticationCloudCredentials({ username: userName, password: password }));\n  return client;\n};\n\nexports.createCdnManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-cdn');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createRedisCacheManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-rediscache');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createHDInsightManagementClient = function (subscription) {\n    var factoryMethod = require('azure-arm-hdinsight').createHDInsightManagementClient;\n    return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createHDInsightJobManagementClient = function (subscription) {\n    var factoryMethod = require('azure-arm-hdinsight-jobs').createHDInsightJobManagementClient;\n    return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createInsightsClient = function (subscription) {\n  var factoryMethod = require('azure-arm-insights').createInsightsClient;\n  return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createInsightsManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-insights').createInsightsManagementClient;\n  return _createArmClient(factoryMethod, subscription);\n};\n\n//website provider might not be registered yet, so make sure to register it\nexports.createWebsiteClient = function (subscription, callback) {\n  var client;\n  subscription.registerAsmProvider('website', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    var factoryMethod = require('azure-asm-website').createWebSiteManagementClient;\n    client = _createAsmClient(factoryMethod, subscription);\n    return callback(null, client);\n  });\n};\n\nexports.createWebSiteExtensionsClient = function (siteName, hostNameSuffix, username, password) {\n  var baseUri = util.format('https://%s.scm.%s:443', siteName, hostNameSuffix);\n  var azureWebSite = require('azure-asm-website');\n  var service = azureWebSite.createWebSiteExtensionsClient(siteName, new azureWebSite.createBasicAuthenticationCloudCredentials({\n    username: username,\n    password: password,\n  }), baseUri)\n    .withFilter(log.createLogFilter())\n    .withFilter(cliUserAgentFilter.create(getUserAgent()))\n    .withFilter(createPostBodyFilter())\n    .withFilter(createFollowRedirectFilter())\n    .withFilter(commandMetadataFilter.create(userAgentCore.getCommandData()));\n\n  return service;\n};\n\nexports.createWebappManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-website');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createUsageManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-commerce');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createSqlClient = function (subscription) {\n  var factoryMethod = require('azure-asm-sql').createSqlManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createServiceBusClient = function (subscription) {\n  var factoryMethod = require('azure-asm-sb').createServiceBusManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createManagementClient = function (subscription) {\n  var factoryMethod = require('azure-asm-mgmt').createManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createStorageClient = function (subscription) {\n  var factoryMethod = require('azure-asm-storage').createStorageManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createStorageResourceProviderClient = function (subscription) {\n  var clientConstructor = require('azure-arm-storage');\n  return this.createAutoRestClient(clientConstructor, subscription);\n};\n\nexports.createServerManagementClient = function(subscription) { \n  var clientConstructor = require('azure-arm-servermanagement');\n  return this.createAutoRestClient(clientConstructor, subscription);\n};\n\nexports.createBatchResourceProviderClient = function (subscription) {\n  var factoryMethod = require('azure-arm-batch');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createBatchClient = function (accountName, accountKey, taskUri) {\n  var batch = require('azure-batch');\n  var credentials = new batch.SharedKeyCredentials(accountName, accountKey);\n\n  var options = {};\n  options.filters = [\n      log.createLogFilter(),\n      cliUserAgentFilter.create(exports.getUserAgent()),\n      exports.createPostBodyFilter(),\n      exports.createFollowRedirectFilter(),\n      commandMetadataFilter.create(userAgentCore.getCommandData())\n  ];\n  options.generateClientRequestId = false;\n  \n  var client = new batch.ServiceClient(credentials, taskUri, options);\n  return client;\n};\n\n/**\n * Deprecated, use createComputeManagementClient instead.\n */\nexports.createComputeResourceProviderClient = function (subscription) {\n  // TODO: delete 'armsdk' folder after migration to autorest SDK\n  var factoryMethod = require('./../commands/arm/armsdk/compute').createComputeResourceProviderClient;\n  return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createComputeManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-compute');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createNetworkManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-network');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createPowerbiManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-powerbiembedded');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createGraphManagementClient = function (subscription) {\n  var factoryMethod = require('azure-graph');\n  // Specify tenant based client and endpoint in options\n  var options = { isTenantBased: true, endPoint: subscription.activeDirectoryGraphResourceId };\n  return this.createAutoRestClient(factoryMethod, subscription, options);\n};\n\nexports.createTrafficManagerResourceProviderClient = function (subscription) {\n  var factoryMethod = require('azure-arm-trafficmanager');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createDnsResourceProviderClient = function (subscription) {\n  var factoryMethod = require('azure-arm-dns');\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createComputeClient = function (subscription) {\n  var factoryMethod = require('azure-asm-compute').createComputeManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createNetworkClient = function (subscription) {\n  var factoryMethod = require('azure-asm-network').createNetworkManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createTrafficManagerClient = function (subscription) {\n  var factoryMethod = require('azure-asm-trafficmanager').createTrafficManagerManagementClient;\n  return _createAsmClient(factoryMethod, subscription);\n};\n\nexports.createResourceClient = function (subscription) {\n  var factoryMethod = require('azure-arm-resource').ResourceManagementClient;\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createSubscriptionClient = function (subscription) {\n  var options = {\n    noSubscription: true,\n    requiresBaseUri: true\n  };\n  var factoryMethod = require('azure-arm-resource').SubscriptionClient;\n  return this.createAutoRestClient(factoryMethod, subscription, options);\n};\n\nexports.createPolicyClient = function (subscription) {\n  var factoryMethod = require('azure-arm-resource').PolicyClient;\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createResourceManagerClient = function (subscription) {\n  // TODO: delete 'armsdk' folder after migration to autorest SDK\n  var factoryMethod = require('./../commands/arm/armsdk/resource').createResourceManagementClient;\n  return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createResourceFeatureClient = function (subscription) {\n  var factoryMethod = require('azure-arm-resource').FeatureClient;\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createEventsClient = function (subscription) {\n  var factoryMethod = require('azure-monitoring').createEventsClient;\n  return _createArmClient(factoryMethod, subscription);\n};\n\nexports.createKeyVaultClient = function (subscription) {\n  var keyvault = require('azure-keyvault');\n  \n  var authenticator = function (challenge, callback) {\n    // challenge.resource contains keyvault resourceId\n    var retrieveTokenCallback = function(err, scheme, token) {\n      return callback(err, util.format('%s %s', scheme, token));\n    };\n    var tokenCredentials = subscription._createCredentials(challenge.resource);\n    return tokenCredentials.retrieveTokenFromCache(retrieveTokenCallback);\n  };\n  \n  var credentials;\n  if(subscription.user) {\n    credentials = new keyvault.KeyVaultCredentials(authenticator);\n  } else if(subscription.managementCertificate) {\n    credentials = subscription._createCredentials();\n  } else {\n    throw new Error('Unsupported subscription object.');\n  }\n\n  var options = {\n    filters: [\n      exports.certAuthFilter(credentials),\n      cliUserAgentFilter.create(exports.getUserAgent()),\n      exports.createPostBodyFilter(),\n      polishErrorCausedByArmProviderNotRegistered(),\n      commandMetadataFilter.create(userAgentCore.getCommandData())\n    ]\n  };\n\n  return keyvault.createKeyVaultClient(credentials, options);\n};\n\nexports.createGalleryClient = function (subscription) {\n  var factoryMethod = require('azure-gallery').createGalleryClient;\n  return exports.createClient(factoryMethod,\n    new azureCommon.AnonymousCloudCredentials(),\n    subscription.galleryEndpointUrl);\n};\n\nexports.createMobileClient = function (subscription) {\n  return _createAsmClient(function (credentials) {\n\n    //propagates errors that ErrorHandlingFilter in azureCommon.Service would swallow\n    var errorPropagationFilter = function handle(resource, next, callback) {\n      return next(resource, function (err, response, body) {\n        if (body !== undefined && response !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n          callback(body, response, body);\n        } else {\n          callback(err, response, body);\n        }\n      });\n    };\n\n    var client = new azureCommon.Service(credentials, [errorPropagationFilter]);\n    client.longRunningOperationRetryTimeout = 5000;\n    return client;\n  }, subscription);\n};\n\nexports.createDataLakeStoreFileSystemManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-datalake-store').DataLakeStoreFileSystemClient;\n  var options = {\n    noSubscription: true,\n    dnsSuffix: subscription.azureDataLakeStoreFileSystemEndpointSuffix,\n  };\n  \n  return this.createAutoRestClient(factoryMethod, subscription, options);\n};\n\nexports.createDataLakeStoreManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-datalake-store').DataLakeStoreAccountClient;\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createDataLakeAnalyticsManagementClient = function (subscription) {\n  var factoryMethod = require('azure-arm-datalake-analytics').DataLakeAnalyticsAccountClient;\n  return this.createAutoRestClient(factoryMethod, subscription);\n};\n\nexports.createDataLakeAnalyticsJobManagementClient = function (subscription) {\n  var options = {\n    noSubscription: true,\n    dnsSuffix: subscription.azureDataLakeAnalyticsCatalogAndJobEndpointSuffix\n  };\n  var factoryMethod = require('azure-arm-datalake-analytics').DataLakeAnalyticsJobClient;\n  return this.createAutoRestClient(factoryMethod, subscription, options);\n};\n\nexports.createDataLakeAnalyticsCatalogManagementClient = function (subscription) {\n  var options = {\n    noSubscription: true,\n    dnsSuffix: subscription.azureDataLakeAnalyticsCatalogAndJobEndpointSuffix\n  };\n  \n  var factoryMethod = require('azure-arm-datalake-analytics').DataLakeAnalyticsCatalogClient;\n  return this.createAutoRestClient(factoryMethod, subscription, options);\n};\n\nexports.createDevTestLabsClient = function (subscription) {\n    var clientConstructor = require('azure-arm-devtestlabs');\n    return this.createAutoRestClient(clientConstructor, subscription);\n};\n\nexports.getiotHubClient = function (subscription) {\n    var clientConstructor = require('azure-arm-iothub');\n    return this.createAutoRestClient(clientConstructor, subscription);\n};\n\n/**\n * Create old-style service object\n * @param {string} serviceFactoryName name of factory function off azure module\n */\nfunction createService(factoryMethod, subscription) {\n  var managementEndpoint = url.parse(subscription.managementEndpointUrl);\n  var service = factoryMethod(subscription.id, {\n    keyvalue: subscription.managementCertificate.key,\n    certvalue: subscription.managementCertificate.cert,\n  },\n    {\n      host: managementEndpoint.hostname,\n      port: managementEndpoint.port,\n      serializetype: 'XML'\n    }).withFilter(new RequestLogFilter(log));\n  return service;\n}\n\nexports.createWebsiteManagementService = function (subscription) {\n  var factoryMethod = require('azure-asm-website').createWebsiteManagementService;\n  return createService(factoryMethod, subscription);\n};\n\n// TODO: workaround for release 0.7.4. Remove in vnext and fix underlying issue in SDK.\nfunction createPostBodyFilter() {\n  return function handle(resource, next, callback) {\n    if ((resource.method === 'POST' || resource.method === 'PUT' || resource.method === 'PATCH') && !resource.body) {\n      resource.body = '';\n    }\n\n    var stream = next(resource, callback);\n    stream.on('error', function () {\n    });\n    return stream;\n  };\n}\n\nexports.createPostBodyFilter = createPostBodyFilter;\n\nfunction certAuthFilter(credentials) {\n  return function handle(resource, next, callback) {\n    if (credentials && credentials.credentials && credentials.credentials.key && credentials.credentials.cert) {\n      resource.key = credentials.credentials.key;\n      resource.cert = credentials.credentials.cert;\n    }\n    return next(resource, callback);\n  };\n}\n\nexports.certAuthFilter = certAuthFilter;\n\nfunction createFollowRedirectFilter() {\n  return function handle(resource, next, callback) {\n    function handleRedirect(err, response, body) {\n      if (response &&\n        response.headers.location &&\n        response.statusCode >= 300 &&\n        response.statusCode < 400) {\n\n        resource.url = response.headers.location;\n        next(resource, handleRedirect);\n      } else if (callback) {\n        callback(err, response, body);\n      }\n    }\n\n    return next(resource, handleRedirect);\n  };\n}\n\nexports.createFollowRedirectFilter = createFollowRedirectFilter;\n\npolishErrorCausedByArmProviderNotRegistered = function () {\n  return function handle(resource, next, callback) {\n    var nextStream = next(resource, function (err, response, body) {\n      if (err && err.message && response && response.statusCode === 409) {\n        var re = /.*registered to use namespace \\'(.+)\\'/i;\n        var found = re.exec(err.message);\n        var providerName = (found && found.length === 2) ? found[1] : null;\n        if (providerName) {\n          err.message = util.format('The subscription must be registered to use namespace \"%s\". ' +\n                                    'This can be achieved by executing the command: \"azure provider ' +\n                                    'register %s\".', providerName, providerName);\n        }\n      }\n      callback(err, response, body);\n    });\n    return nextStream;\n  };\n};\n\nexports.createScmManagementService = function (repository, auth) {\n  var authentication = auth.split(':');\n  var repositoryUrl = url.parse(repository);\n  var azureWebSite = require('azure-asm-website');\n\n  var service = azureWebSite.createScmService({\n    user: authentication[0],\n    pass: authentication[1]\n  }, {\n    host: repositoryUrl.hostname,\n    port: repositoryUrl.port\n  });\n\n  service.userAgent = getUserAgent();\n\n  return service;\n};\n\nexports.createBlobService = function () {\n  var storage = require('azure-storage');\n  var blobService = storage.createBlobService.apply(this, arguments);\n  blobService.userAgent = getUserAgent();\n  return blobService;\n};\n\nexports.createSqlService = function () {\n  var azureSqlMgmt = require('azure-asm-sql');\n  var sqlService = azureSqlMgmt.createSqlService.apply(this, arguments);\n  sqlService.userAgent = getUserAgent();\n  return sqlService;\n};\n\nexports.getLocaleString = function (string) {\n  var result = locale[string];\n  if (!result) {\n    if (process.env.AZURE_DEBUG_LABELS) {\n      throw new Error(util.format('Invalid resource %s', string));\n    } else {\n      return string;\n    }\n  }\n\n  return result;\n};\n\nfunction RequestLogFilter(logger) {\n  this.logger = logger;\n}\n\nRequestLogFilter.prototype.handle = function (requestOptions, next) {\n  var self = this;\n\n  this.logger.silly('requestOptions');\n  this.logger.json('silly', requestOptions);\n  if (next) {\n    next(requestOptions, function (returnObject, finalCallback, nextPostCallback) {\n      self.logger.silly('returnObject');\n      self.logger.json('silly', returnObject);\n\n      if (nextPostCallback) {\n        nextPostCallback(returnObject);\n      } else if (finalCallback) {\n        finalCallback(returnObject);\n      }\n    });\n  }\n};\n\nexports.RequestLogFilter = RequestLogFilter;\n\nexports.isSha1Hash = function (str) {\n  return (/\\b([a-fA-F0-9]{40})\\b/).test(str);\n};\n\nexports.webspaceFromName = function (name) {\n  return (name.replace(/ /g, '').toLowerCase() + 'webspace');\n};\n\nexports.getCertFingerprint = function (pem) {\n  var certBase64 = exports.extractBase64CertFromPEM(pem);\n  // Calculate sha1 hash of the cert\n  var cert = new Buffer(certBase64, 'base64');\n  var sha1 = crypto.createHash('sha1');\n  sha1.update(cert);\n  return sha1.digest('hex');\n};\n\nexports.isPemCert = function (data) {\n  return data.indexOf(BEGIN_CERT) !== -1 && data.indexOf(END_CERT) !== -1;\n};\n\nexports.extractBase64CertFromPEM = function (pem) {\n  // Extract the base64 encoded cert out of pem file\n  var beginCert = pem.indexOf(BEGIN_CERT) + BEGIN_CERT.length;\n  if (pem[beginCert] === '\\n') {\n    beginCert = beginCert + 1;\n  } else if (pem[beginCert] === '\\r' && pem[beginCert + 1] === '\\n') {\n    beginCert = beginCert + 2;\n  }\n\n  var endCert = '\\n' + pem.indexOf(END_CERT);\n  if (endCert === -1) {\n    endCert = '\\r\\n' + pem.indexOf(END_CERT);\n  }\n\n  return pem.substring(beginCert, endCert);\n};\n\nexports.getOrCreateBlobStorage = function (cli, storageClient, location, affinityGroup, name, storagePrefix, callback) {\n  var progress;\n\n  /*jshint camelcase:false*/\n  function callback_(error, blobStorageUrl) {\n    progress.end();\n    callback(error, blobStorageUrl);\n  }\n\n  function createNewStorageAccount_() {\n    if (exports.stringIsNullOrEmpty(storagePrefix)) {\n      storagePrefix = name;\n    }\n    var storageAccountName = blobUtils.normalizeServiceName(storagePrefix + (new Date()).getTime().toString());\n    cli.output.verbose('Creating a new storage account \\'' + storageAccountName + '\\'');\n    var storageOptions = {\n      name: storageAccountName,\n      label: storageAccountName,\n      geoReplicationEnabled: false,\n      accountType: 'Standard_LRS'\n    };\n\n    if (affinityGroup) {\n      storageOptions.affinityGroup = affinityGroup;\n    } else if (location) {\n      storageOptions.location = location;\n    } else {\n      throw new Error('location or affinityGroup must be specified');\n    }\n\n    progress = cli.interaction.progress('Creating a new storage account \\'' + storageAccountName + '\\'');\n    storageClient.storageAccounts.create(storageOptions, function (error) {\n      if (error) {\n        callback_(error);\n      } else {\n        cli.output.verbose('Storage account successfully created');\n        cli.output.verbose('Getting properties for \\'' + storageAccountName + '\\' storage account');\n\n        storageClient.storageAccounts.get(storageAccountName, function (error, response) {\n          if (error) {\n            callback_(error);\n          } else {\n            var storageAccount = response.storageAccount;\n            if (storageAccount) {\n              var blobStorageUrl = storageAccount.properties.endpoints[0];\n              if (blobStorageUrl.slice(-1) === '/') {\n                blobStorageUrl = blobStorageUrl.slice(0, -1);\n              }\n\n              callback_(null, blobStorageUrl);\n            } else {\n              callback_(new Error('No storage account found'));\n            }\n          }\n        });\n      }\n    });\n  }\n\n  progress = cli.interaction.progress('Retrieving storage accounts');\n  cli.output.verbose('Getting list of available storage accounts');\n  storageClient.storageAccounts.list(function (error, response) {\n    if (error) {\n      callback_(error);\n    } else {\n      var storageAccounts = response.storageAccounts;\n      for (var i = 0; i < storageAccounts.length; i++) {\n        if ((location && storageAccounts[i].properties.location && storageAccounts[i].properties.location.toLowerCase() === location.toLowerCase()) ||\n          affinityGroup && storageAccounts[i].properties.affinityGroup && storageAccounts[i].properties.affinityGroup.toLowerCase() === affinityGroup.toLowerCase()) {\n          if (!exports.stringIsNullOrEmpty(storagePrefix)) {\n            if (!exports.stringStartsWith(storageAccounts[i].name, storagePrefix)) {\n              continue;\n            }\n          }\n          var blobStorageUrl = storageAccounts[i].properties.endpoints[0];\n          if (blobStorageUrl.slice(-1) === '/') {\n            blobStorageUrl = blobStorageUrl.slice(0, -1);\n          }\n\n          callback_(null, blobStorageUrl);\n          return;\n        }\n      }\n      createNewStorageAccount_();\n    }\n  });\n};\n\nexports.writeFileSyncMode = function writeFileSyncMode(path, data, encoding, mode) {\n  mode = mode || parseInt('600', 8); // maximum protection by default\n  var fd = fs.openSync(path, 'w', mode);\n  try {\n    if (typeof data === 'string') {\n      fs.writeSync(fd, data, 0, encoding);\n    } else {\n      fs.writeSync(fd, data, 0, data.length, 0);\n    }\n  } finally {\n    fs.closeSync(fd);\n  }\n};\n\nexports.getDnsPrefix = function (dnsName, allowEmpty) {\n  if (dnsName) {\n    // remove protocol if any, take the last element\n    dnsName = dnsName.split('://').slice(-1)[0];\n    // take first element\n    dnsName = dnsName.split('.', 1)[0];\n  }\n  if (!dnsName && !allowEmpty) {\n    throw new Error('Missing or invalid dns-name');\n  }\n  return dnsName;\n};\n\n/**\n * Resolve location name if 'name' is location display name.\n *\n * @param {string}   name       The display name or location name. Required\n * @param {function} callback   The callback function called on completion. Required.\n */\nexports.resolveLocationName = function (managementClient, name, callback) {\n  managementClient.locations.list(function (error, response) {\n    var resolvedLocation = null;\n    if (!error) {\n      if (response.locations.length > 0) {\n        for (var i = 0; i < response.locations.length; i++) {\n          var locationInfo = response.locations[i];\n          if (exports.ignoreCaseEquals(locationInfo.name, name)) {\n            callback(null, locationInfo);\n            return;\n          } else if (!resolvedLocation && (exports.ignoreCaseEquals(locationInfo.DisplayName, name))) {\n            // This is the first matched display name save the corresponding location\n            // We ignore further matched display name, but will continue with location\n            // matching\n            resolvedLocation = locationInfo;\n          }\n        }\n\n        if (resolvedLocation) {\n          callback(null, resolvedLocation);\n        } else {\n          callback({\n            message: 'No location found which has DisplayName or Name same as value of --location',\n            code: 'Not Found'\n          }, name);\n        }\n      } else {\n        // Return a valid error\n        callback({ message: 'Server returns empty location list', code: 'Not Found' }, name);\n      }\n    } else {\n      callback(error, null);\n    }\n  });\n};\n\nexports.parseInt = function (value) {\n  var intValue = parseInt(value, 10);\n  if (intValue != value || value >= 65536 * 65536) { // just some limits\n    return NaN;\n  }\n  return intValue;\n};\n\nexports.parseBool = function (value, paramName) {\n  if (!this.ignoreCaseEquals(value, 'true') && !this.ignoreCaseEquals(value, 'false')) {\n    throw new Error(util.format('%s parameter must be true or false', paramName));\n  }\n  return value.toLowerCase() === 'true';\n};\n\n/**\n * Creates a anonymous function that validator if the given string is a valid datetime.\n *\n * @param {string} stringDateTime The datetime string.\n * @return {Date}\n */\nexports.parseDateTime = function (stringDateTime) {\n  try {\n    return new Date(stringDateTime);\n  } catch (e) {\n    throw new Error($('The date format is incorrect'));\n  }\n};\n\nexports.getUTCTimeStamp = function () {\n  var now = new Date();\n  return (now.getUTCFullYear() + '-' +\n  ('0' + (now.getUTCMonth() + 1)).slice(-2) + '-' +\n  ('0' + now.getUTCDate()).slice(-2) + ' ' +\n  ('0' + now.getUTCHours()).slice(-2) + ':' +\n  ('0' + now.getUTCMinutes()).slice(-2));\n};\n\nexports.logLineFormat = function logLineFormat(object, logFunc, prefix) {\n  prefix = prefix || '';\n  switch (typeof object) {\n    case 'object':\n      // if this is a date then we call toISOString and print that\n      if (_.isDate(object)) {\n        logFunc(prefix.cyan + object.toISOString().green);\n      } else {\n        for (var i in object) {\n          logLineFormat(object[i], logFunc, prefix + i + ' ');\n        }\n      }\n      return;\n    case 'string':\n      logFunc(prefix.cyan + ('\"' + object + '\"').green);\n      return;\n    case 'boolean':\n      logFunc(prefix.cyan + object.toString().green);\n      return;\n    case 'number':\n      logFunc(prefix.cyan + object.toString().green);\n      return;\n    case 'undefined':\n      return;\n    default:\n      logFunc(prefix.cyan + '?' + object + '?'); // unknown type\n  }\n};\n\nexports.validateEndpoint = function (endpoint) {\n  if (!exports.stringStartsWith(endpoint, 'http://') && !exports.stringStartsWith(endpoint, 'https://')) {\n    // Default to https\n    endpoint = 'https://' + endpoint;\n  }\n\n  var parts = url.parse(endpoint);\n  if (!parts.hostname) {\n    throw new Error('Invalid endpoint format.');\n  }\n\n  parts.port = (parts.port && parseInt(parts.port, 10)) || (/https/i.test(parts.protocol) ?\n    constants.DEFAULT_HTTPS_PORT :\n    constants.DEFAULT_HTTP_PORT);\n\n  return url.format(parts);\n};\n\n/**\n * Determines if a string is null or empty.\n *\n * @param {string}       text      The string to test.\n * @return {Bool} True if the string string is null or empty; false otherwise.\n */\nexports.stringIsNullOrEmpty = function (text) {\n  return text === null ||\n    text === undefined ||\n    text.trim() === '';\n};\n\n\nexports.stripBOM = function (content) {\n  if (Buffer.isBuffer(content)) {\n    content = content.toString();\n  }\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Determines if a string ends with another.\n *\n * @param {string}       text      The string to assert.\n * @param {string}       suffix    The string suffix.\n * @param {bool}         ignoreCase Boolean value indicating if casing should be ignored.\n * @return {Bool} True if the string ends with the suffix; false otherwise.\n */\nexports.stringEndsWith = function (text, suffix, ignoreCase) {\n  if (_.isNull(suffix)) {\n    return true;\n  }\n\n  if (ignoreCase) {\n    text = text.toLowerCase();\n    suffix = suffix.toLowerCase();\n  }\n\n  return text.substr(text.length - suffix.length) === suffix;\n};\n\nexports.stringTrimEnd = function (text, charToTrim) {\n  if (!text) {\n    return text;\n  }\n\n  if (!charToTrim) {\n    charToTrim = ' ';\n  }\n\n  var subtract = 0;\n  while (subtract < text.length && text[text.length - (subtract + 1)] === charToTrim) {\n    subtract++;\n  }\n\n  return text.substr(0, text.length - subtract);\n};\n\n\nexports.logError = function (log, message, err) {\n  if (arguments.length == 1) {\n    err = message;\n    message = undefined;\n  } else {\n    log.error(message);\n  }\n\n  if (err) {\n    if (err.message) {\n      //                log.error(err.message);\n      log.verbose('stack', err.stack);\n      log.json('silly', err);\n    }\n    else if (err.Message) {\n      //                log.error(err.Message);\n      log.json('verbose', err);\n    }\n  }\n};\n\nexports.clearConfig = function () {\n  var azureConfigPath = path.join(exports.azureDir(), 'config.json');\n\n  if (exports.pathExistsSync(azureConfigPath)) {\n    fs.unlinkSync(azureConfigPath);\n    return true;\n  }\n};\n\nexports.copyIisNodeWhenServerJsPresent = function (log, rootPath, callback) {\n  try {\n    var iisnodeyml = 'iisnode.yml';\n    log.silly('copyWebConfigWhenServerJsPresent');\n    if (!exports.pathExistsSync(iisnodeyml) && (exports.pathExistsSync(path.join(rootPath, 'server.js')) || exports.pathExistsSync(path.join(rootPath, 'app.js')))) {\n      log.info('Creating default ' + iisnodeyml + ' file');\n      var sourcePath = path.join(__dirname, '../templates/node/' + iisnodeyml);\n      fs.readFile(sourcePath, function (err, result) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        fs.writeFile(path.join(rootPath, iisnodeyml), result, callback);\n      });\n    }\n    else {\n      callback();\n    }\n  }\n  catch (e) {\n    callback(e);\n  }\n};\n\nexports.normalizeParameters = function (paramDescription) {\n  var key, positionalValue, optionValue;\n  var paramNames = Object.keys(paramDescription);\n  var finalValues = {};\n\n  for (var i = 0; i < paramNames.length; ++i) {\n    key = paramNames[i];\n    positionalValue = paramDescription[key][0];\n    optionValue = paramDescription[key][1];\n    if (!_.isUndefined(positionalValue) && !_.isUndefined(optionValue)) {\n      return { err: new Error('You must specify ' + key + ' either positionally or by name, but not both') };\n    } else {\n      finalValues[key] = positionalValue || optionValue;\n    }\n  }\n\n  return { values: finalValues };\n};\n\n/**\n * fs.exists wrapper for streamline\n */\nexports.fileExists = function (filePath, cb) {\n  var func = fs.exists;\n  if (!func) {\n    func = path.exists;\n  }\n  func(filePath, function (exists) {\n    cb(null, exists);\n  });\n};\n\n/**\n * Wildcard Util only support two wildcard character * and ?\n */\nexports.Wildcard = {\n  /**\n   * does the specified the character contain wildcards\n   */\n  containWildcards: function (str) {\n    var wildcardReg = /[*?]/img;\n    return str !== null && wildcardReg.test(str);\n  },\n\n  /**\n   * Get the max prefix string of the specified string which doesn't contain wildcard\n   */\n  getNonWildcardPrefix: function (str) {\n    var nonWildcardReg = /[^*?]*/img;\n    var prefix = '';\n\n    if (str !== null) {\n      var result = str.match(nonWildcardReg);\n      if (result !== null && result.length > 0) {\n        prefix = result[0];\n      }\n    }\n\n    return prefix;\n  },\n\n  /**\n   * Convert wildcard pattern to regular expression\n   */\n  wildcardToRegexp: function (str, isCaseInsensitive) {\n    var strRegexp = '';\n    if (str !== null) {\n      strRegexp = str.replace(/\\?/g, '.').replace(/\\*/g, '.*');\n    }\n\n    var regexp = new RegExp();\n    if (isCaseInsensitive && isCaseInsensitive === true) {\n      regexp.compile('^' + strRegexp + '$', 'ig');\n    }\n    else {\n      regexp.compile('^' + strRegexp + '$');\n    }\n    return regexp;\n  },\n\n  /**\n   * Is the specified string match the case sensitive specified wildcard pattern\n   */\n  isMatch: function (str, pattern) {\n    var reg = exports.Wildcard.wildcardToRegexp(pattern);\n    return reg.test(str);\n  },\n  \n  /**\n   * Is the specified string match the case insensitive specified wildcard pattern\n   */\n  isMatchCaseInsensitive: function (str, pattern) {\n    var reg = exports.Wildcard.wildcardToRegexp(pattern, true);\n    return reg.test(str);\n  }\n};\n\n/**\n * Invalid file name chars in windows.\n * http://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx\n */\nexports.invalidFileNameChars = [34, 60, 62, 124, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 58, 42, 63, 92, 47];\n\n/**\n * Reserved file name in windows\n */\nexports.reservedBaseFileNamesInWindows = ['con', 'prn', 'aux', 'nul', 'com1', 'com2', 'com3', 'com4', 'com5', 'com6', 'com7', 'com8', 'com9', 'lpt1', 'lpt2', 'lpt3', 'lpt4', 'lpt5', 'lpt6', 'lpt7', 'lpt8', 'lpt9'];\n\n/**\n * Is the reserved file name in windows\n */\nexports.isReservedFileNameInWindows = function (name) {\n  name = (name || '').toLowerCase();\n  var index = exports.reservedBaseFileNamesInWindows.indexOf(name);\n  return index !== -1;\n};\n\n/*\n * Escape file path\n */\nexports.escapeFilePath = function (name) {\n  if (exports.isWindows()) {\n    //only escape file name on windows\n    var regExp = exports.getReplaceRegExpFromCharCode(exports.invalidFileNameChars);\n    name = name.replace(regExp, function (code) {\n      return '%' + code.charCodeAt(0).toString(16);\n    });\n    var extName = path.extname(name);\n    var baseName = path.basename(name, extName);\n    if (exports.isReservedFileNameInWindows(baseName)) {\n      name = util.format('%s (1)%s', baseName, extName);\n    }\n  }\n  return name;\n};\n\n/**\n * Is windows platform\n */\nexports.isWindows = function () {\n  return !!process.platform.match(/^win/);\n};\n\n/**\n * Join the char code into a replace regular expression\n * For example,\n *   [65,66] => /A|B/img\n *   [63,66] => /\\?|B/img\n */\nexports.getReplaceRegExpFromCharCode = function (charCodeArray) {\n  function charCodeToRegChar(charCode) {\n    var str = String.fromCharCode(charCode);\n    switch (str) {\n      case '*':\n      case '?':\n      case '.':\n      case '\\\\':\n      case '|':\n      case '/':\n        str = '\\\\' + str;\n        break;\n    }\n    return str;\n  }\n\n  var regExp = new RegExp();\n  if (charCodeArray.length) {\n    var regStr = charCodeToRegChar(charCodeArray[0]);\n    for (var i = 1; i < charCodeArray.length; i++) {\n      regStr += '|' + charCodeToRegChar(charCodeArray[i]);\n    }\n    regExp.compile(regStr, 'gim');\n  }\n  return regExp;\n};\n\n/**\n * Add function overloads to an object that vary by\n * declared argument length.\n *\n * @param {function} func the function overloads.\n *\n * @returns The 'overloaded' function\n */\nexports.overload = function () {\n\n  function final() {\n    throw new Error(util.format($('Unknown overload for %s parameters'), arguments.length));\n  }\n\n  var func = final;\n  /* jshint loopfunc: true */\n  for (var i = 0; i < arguments.length; ++i) {\n    func = (function (old, func) {\n      return function () {\n        if (func.length === arguments.length) {\n          return func.apply(this, arguments);\n        } else if (typeof old === 'function') {\n          return old.apply(this, arguments);\n        }\n      };\n    })(func, arguments[i]);\n  }\n\n  return func;\n};\n\n//\"<root>\\test\\framework\\cli-test.js\" contains associated test stubs. Please keep them in sync.\nexports.uuidGen = function () {\n  return uuid.v4();\n};\n\n//Provides a random string starting with the given (string) prefix. If prefix is not provided \n//then it provides a random alphanumeric string\nexports.getRandomString = function (prefix) {\n  var randomStr = Math.random().toString(36).substr(2, 12);\n  if (prefix !== null && prefix !== undefined && typeof prefix.valueOf() === 'string') {\n    return prefix + randomStr;\n  }\n  return randomStr;\n};\n\nexports.toLowerCaseAndRemoveSpace = function (str) {\n  if (!str) {\n    return str;\n  }\n\n  return str.replace(/ /gi, '').toLowerCase();\n};\n\nexports.ignoreCaseAndSpaceEquals = function (a, b) {\n  return a === b || (exports.toLowerCaseAndRemoveSpace(a) === exports.toLowerCaseAndRemoveSpace(b));\n};\n\nexports.atLeastOneParameIsSet = function (params) {\n  for (var i = 0; i < params.length; i++) {\n    if (!exports.stringIsNullOrEmpty(params[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexports.allParamsAreSet = function (params) {\n  for (var i = 0; i < params.length; i++) {\n    if (exports.stringIsNullOrEmpty(params[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// Many of the commands accepts arguments whose valid values can be from an enum. For example\n// protocol argument for endpoints create, valid values are ['tcp', 'udp', 'http'].\n// This method can be used to validate user provided input against the possible valid\n// values (supportedTypes). This method do case ignore comparison and return matched enum\n// value. If no match found exception will be thrown and exception message will inform valid\n// values.\nexports.verifyParamExistsInCollection = function (supportedTypes, paramToCheck, paramName) {\n  var i = _.indexOf(_.map(supportedTypes, function (s) {\n    return s.toLowerCase();\n  }), paramToCheck.toLowerCase());\n  if (i === -1) {\n    throw new Error(util.format(exports.getLocaleString('Given %s \"%s\" is invalid, supported values are: %s'), paramName, paramToCheck, supportedTypes.join(', ')));\n  }\n\n  return supportedTypes[i];\n};\n\nexports.hasValidProperty = function (object, propName) {\n  if (object === null || object === undefined) {\n    return false;\n  }\n\n  if (!object.hasOwnProperty(propName)) {\n    return false;\n  }\n\n  if (object[propName] === null || object[propName] === undefined) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.parseResourceReferenceUri = function (referenceUri) {\n  var parts = referenceUri.split('/');\n  return {\n    subscriptionId: parts[2],\n    resourceGroupName: parts[4],\n    provider: parts[6], // e.g. Microsoft.Network\n    parentResource: parts.slice(7, parts.length - 1).join('/'), // e.g. virtualNetworks/<vnet-name>/subnets\n    resourceName: parts[parts.length - 1] // e.g. <subnet-name>\n  };\n};\n\nexports.isAttributesMatched = function (item, attributes) {\n  for (var key in attributes) {\n    var value1 = attributes[key];\n    var value2 = item[key];\n    if (typeof value1 === 'string' && typeof value2 === 'string') {\n      value1 = value1.toLowerCase();\n      value2 = value2.toLowerCase();\n    }\n    if (value1 !== value2) return false;\n  }\n\n  return true;\n};\n\n/**\n * Looks through the list and returns the element that matches attributes,\n * case-insensitive.\n */\nexports.findFirstCaseIgnore = function (list, attributes) {\n  if (_.isEmpty(attributes)) {\n    return undefined;\n  }\n  return _.find(list, function (item) {\n    return exports.isAttributesMatched(item, attributes);\n  });\n};\n\n/**\n * Looks through the list and returns the index of element that matches attributes or -1 if it is not present,\n * case-insensitive.\n */\nexports.indexOfCaseIgnore = function (list, attributes) {\n  if (_.isEmpty(list) || _.isEmpty(attributes)) {\n    return -1;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var match = exports.isAttributesMatched(item, attributes);\n    if (match) return i;\n  }\n  return -1;\n};\n\nexports.argHasValue = function (argument) {\n  return (argument !== true && argument !== '\\'\\'');\n};\n\nexports.trimTrailingChar = function (str, charToTrim) {\n  while (str.length > 0 && str.charAt(str.length - 1) == charToTrim) {\n    str = str.substr(0, str.length - 1);\n  }\n  return str;\n};\n\nexports.appendArray = function (array, otherArray) {\n  for (var i = 0; i < otherArray.length; i++) {\n    array.push(otherArray[i]);\n  }\n};\n\nexports.capitalizeFirstLetter = function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexports.toRange = function (array) {\n  return '[' + array[0] + '-' + array[1] + ']';\n};\n\nexports.setIndent = function(num) {\n  if (num > 0) {\n    return new Array(num + 1).join(' ');\n  }\n  return '';\n};\n\nexports.getHash = function (name) {\n  // Define Utility Functions - Reference: http://www.cse.yorku.ca/~oz/hash.html\n  var hash = 5381;\n  var seedstr = name;\n  for (var i = 0; i < seedstr.length; i++) {\n    var c = parseInt(seedstr.charCodeAt(i));\n    hash = ((((hash << 5) + hash) + c) % Number.MAX_VALUE) >>> 0;\n  }\n  return hash;\n};\n\nexports.vmImageAliasUrl = 'https://raw.githubusercontent.com/Azure/azure-rest-api-specs/master/arm-compute/quickstart-templates/aliases.json';\n\nexports.getImageAliasFilePath = function() {\n  return __dirname + '/aliases/image.json';\n};\n\nexports.getImageAliasFileContent = function() {\n    var content = fs.readFileSync(exports.getImageAliasFilePath(), 'utf8');\n    content = content.replace(/^\\uFEFF/, '');\n    return content;\n};\n\nexports.parseImageAliasDict = function(aliasObj) {\n  var aliasDict = {};\n  var key = null;\n  for (key in aliasObj.outputs.aliases.value.Windows) {\n    aliasDict[key] = aliasObj.outputs.aliases.value.Windows[key];\n  }\n  for (key in aliasObj.outputs.aliases.value.Linux) {\n    aliasDict[key] = aliasObj.outputs.aliases.value.Linux[key];\n  }\n  return aliasDict;\n};\n\nexports.getImageAliasUrn = function(alias, aliasObj) {\n  if (!aliasObj) {\n    var content = exports.getImageAliasFileContent();\n    aliasObj = JSON.parse(content);\n  }\n  var aliasArr = exports.parseImageAliasDict(aliasObj);\n  for (var i in aliasArr) {\n    if (i.toLowerCase() === alias.toLowerCase()) {\n      return [aliasArr[i].publisher, aliasArr[i].offer, aliasArr[i].sku, aliasArr[i].version].join(':');\n    }\n  }\n  return null;\n};\n\nexports.getImageAliasList = function() {\n  var content = null;\n  if (fs.existsSync(exports.getImageAliasFilePath())) {\n    content = exports.getImageAliasFileContent();\n  }\n  else {\n    var request = require('sync-request');\n    var response = request('GET', exports.vmImageAliasUrl);\n    content = response.getBody();\n    exports.writeFileSyncMode(exports.getImageAliasFilePath(), content, 'utf-8');\n  }\n  var aliasObj = JSON.parse(content);\n  var list = [];\n  var aliasArr = exports.parseImageAliasDict(aliasObj);\n  for (var i in aliasArr) {\n    list.push(i + ' = ' + exports.getImageAliasUrn(i, aliasObj));\n  }\n  return list;\n};\n\nexports.takeDefault = function(output, defValue, paramName) {\n  output.warn(util.format(('Using default %s %s'), paramName, defValue));\n  return defValue;\n};\n\nexports.getPublicIp = function(vm) {\n  var publicIPAddress;\n  if(!vm.networkProfile.networkInterfaces[0].expanded.ipConfigurations[0].publicIPAddress) {\n    publicIPAddress = 'N/A';\n  }\n  else {\n    publicIPAddress = vm.networkProfile.networkInterfaces[0].expanded.ipConfigurations[0].publicIPAddress.expanded.ipAddress;\n  }\n  return publicIPAddress;\n};\n\n\n/**\n * trunc\n *\n * truncates the string with '...' endings\n * @returns {string}\n */\nfunction trunc () {\n  var maxLen = arguments[0];\n  return (this.length > maxLen) ? this.substr(0,maxLen-1)+'...' : this;\n}\nString.prototype.trunc = trunc;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/blobUtils.js":"// \n// Copyright (c) Microsoft and contributors.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// \n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\n/**\n * Common utils related to Azure blob storage\n */\n\nexports.applyToBlobUrl = applyToBlobUrl;\nexports.unescape = unescape;\nexports.normalizeServiceName = normalizeServiceName;\n\nvar path = require('path');\nvar qs = require('querystring');\nvar utils = require('./utils');\n\n//Container names must be valid DNS names, and must conform to these rules:\n//* Container names must start with a letter or number, and can contain only letters, numbers, and the dash (-) character.\n//* Every dash (-) character must be immediately preceded and followed by a letter or number; consecutive dashes are not permitted in container names.\n//* All letters in a container name must be lowercase.\n//* Container names must be from 3 through 63 characters long.\n\n// $root is a special container that can exist at the root level and is always valid.\n//\n// prefix container name (if any) in azurizeName() should follow these rules\n\n// A blob name can contain any combination of characters, but reserved URL characters must be properly escaped. A blob name must be at least one character long and cannot be more than 1,024 characters long.\nvar azurizeName =\n  exports.azurizeName =\n    function azurizeName(prefix, filename) {\n\n      if (!filename || typeof prefix !== 'string') {\n        throw new Error('Incorrect parameters for azurizeName() : ' + prefix + ', ' + filename);\n      }\n      if (prefix[0] !== '/') {\n        prefix = '/' + prefix;\n      }\n      // assuming prefix is good\n      // do not escape it, so that we don't use '/'\n      var azureName = path.basename(filename); // remove dir\n      if (azureName.slice(-1) === '.') {\n        // do not end the name with '.', this does not work - add something at the end\n        azureName += '<>'; // anything other than '.', '/' and '\\x00'\n      }\n      return prefix + azureName;\n    };\n\nexports.getBlobName =\n    function getBlobName(cli, storageClient, location, affinityGroup, newName, blob, prefix, filename, storagePrefix, callback) {\n      if (blob) {\n        if (blob[0] === '/') {\n          utils.getOrCreateBlobStorage(cli, storageClient, location, affinityGroup, newName, storagePrefix, function (error, blobEndpoint) {\n            if (error) {\n              callback(error);\n            } else {\n              callback(null, blobEndpoint + blob);\n            }\n          });\n        } else {\n          callback(null, blob);\n        }\n      } else {\n        utils.getOrCreateBlobStorage(cli, storageClient, location, affinityGroup, newName, storagePrefix, function (error, blobEndpoint) {\n          if (error) {\n            callback(error);\n          } else {\n            callback(null, blobEndpoint + azurizeName(prefix, filename));\n          }\n        });\n      }\n    };\n\nvar splitBlobResourceName =\n  exports.splitBlobResourceName =\n    function splitBlobResourceName(blobResourceName) {\n      var blobResourceNameArray = blobResourceName.split('/');\n      var rootSet = blobResourceNameArray.length <= 1;\n      var container = rootSet ? '$root' : blobResourceNameArray[0];\n      var blobName = rootSet ? blobResourceNameArray[0] : blobResourceNameArray.slice(1).join('/');\n      return { container: container, blobName: blobName, rootSet: rootSet };\n    };\n\nvar splitDestinationUri = exports.splitDestinationUri = function splitDestinationUri(destinationUri) {\n      var result = {};\n      var protocolSplit = destinationUri.split('://');\n      var destNameTrimProtocol = protocolSplit.slice(-1)[0]; // last element\n      var destHost = destNameTrimProtocol.split('/')[0];\n      result.accountName = destHost;\n      var hostArray = destHost.split('.');\n      var protocol = '';\n\n      var host = '';\n\n      if (hostArray.length > 1) {\n        result.accountName = hostArray[0];\n        host = hostArray.join('.').split('/')[0];\n      }\n\n      result.host = host;\n      if (protocolSplit.length > 1) {\n        protocol = protocolSplit[0].trim().toLowerCase();\n      } else {\n        protocol = 'http';\n        destinationUri = 'http://' + destinationUri;\n      }\n\n      protocol += '://';\n      if (result.host) {\n        result.host = protocol + result.host;\n      }\n\n      result.resourceName = destNameTrimProtocol.split('/').slice(1).join('/');\n      var splitResource = splitBlobResourceName(result.resourceName);\n      result.container = splitResource.container;\n      result.blobName = splitResource.blobName;\n\n      // for management operations - make sure root is using $root\n      result.normalizedUri = protocol + host + '/' + result.container + '/' + result.blobName;\n\n      return result;\n    };\n\n// This function does two things with an URL\n// 1) adds /$root for root storage and\n// 2) escape the name (if escape argument is true)\nexports.normalizeBlobUri =\n    function normalizeBlobUri(blobUri, escape) {\n      var res = splitDestinationUri(blobUri).normalizedUri;\n      if (escape) {\n        res = applyToBlobUrl(qs.escape, res);\n      }\n      return res;\n    };\n\nvar applyToBlobUrl =\n  exports.applyToBlobUrl =\n    function applyToBlobUrl(operation, url) {\n      var split1 = url.split('://');\n      var split2 = split1[split1.length - 1].split('/');\n      for (var i = 2; i < split2.length; ++i) { // do not escape host and container\n        split2[i] = operation(split2[i]);\n      }\n      split1[split1.length - 1] = split2.join('/');\n      return split1.join('://');\n    };\n\nvar unescape = exports.unescape = function unescape(url) {\n  return applyToBlobUrl(qs.unescape, url);\n};\n\nvar normalizeServiceName = exports.normalizeServiceName = function normalizeServiceName(name) {\n  return name.replace(/[^a-zA-Z0-9]+/g, '').slice(0, 24).toLowerCase();\n};\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/userAgentCore.js":"﻿//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n/*\n * This module exports user agent data that is sent in the request header.\n * The telemetry module is initialized when the CLI is initialized and it\n * already has the diagnostics we need to construct the user agent.\n * The telemetry module sets the user agent data per command and utils.js\n * consumes this to construct the request. We send the basic info\n * (userAgentData) in the user-agent header. The command metadata is sent\n * in 2 separate headers: 'x-ms-command-name' & 'x-ms-parameter-set-name'.\n */\n\nvar _userAgentData;\nvar _commandData = {};\n\nexports.setCommandInfo = function (commandName, parameterSetName) {\n  _commandData.commandName = commandName;\n  _commandData.parameterSetName = parameterSetName ? parameterSetName.trim() : '';\n};\n\nexports.setMode = function (mode) {\n  _userAgentData.mode = mode;\n};\n\nexports.setUserAgentData = function (data) {\n  _userAgentData = data;\n};\n\nexports.getUserAgentData = function () {\n  return _userAgentData;\n};\n\nexports.getCommandData = function () {\n  return _commandData;\n};","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/commandMetadataFilter.js":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\n'use strict';\n\nvar Constants = require('./constants');\n\n/**\n* Creates a filter to add the command name and parameter set in separate headers in a request.\n*\n* @param {object} cmdMetadata The command metadata to be added to the request header.\n*\n* @param {string} cmdMetadata.commandName - The command executed by the customer\n*\n* @param {string} cmdMetadata.parameterSetName The parameterSet used by the customer while executing the command\n*/\nexports.create = function (cmdMetadata) {\n  return function handle (resource, next, callback) {\n    exports._tagRequest(resource, cmdMetadata);\n    return next(resource, callback);\n  };\n};\n\nexports._tagRequest = function (requestOptions, cmdMetadata) {\n  requestOptions.headers[Constants.XMS_COMMAND_NAME] = cmdMetadata.commandName;\n  requestOptions.headers[Constants.XMS_PARAMETER_SET_NAME] = cmdMetadata.parameterSetName;\n};\n\nexports = module.exports;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/cliUserAgentFilter.js":"﻿//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n'use strict';\n\nvar Constants = require('./constants');\n\n/**\n* Creates a filter to add the user agent header in a request.\n*\n* @param {string} userAgent The user agent string to use.\n*/\nexports.create = function (userAgent) {\n  return function handle(resource, next, callback) {\n    // regardless of whether the UA has been set by someone,\n    // just set it flatly to xplat-cli's UA. The app takes care of\n    // constructing the right string, see utils.js\n    resource.headers[Constants.USER_AGENT] = userAgent;\n    return next(resource, callback);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/authentication/file-token-storage.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar fs = require('fs');\n\nvar utils = require('../utils');\n/**\n * Constructs a new disk file based token storage.\n * @constructor\n *\n * @param {string} filename filename to store/retrieve data from\n *\n */\nfunction FileTokenStorage(filename) {\n  this._filename = filename;\n}\n\n_.extend(FileTokenStorage.prototype, {\n  _save: function (entries, done) {\n    var writeOptions = {\n      encoding: 'utf8',\n      mode: 384, // Permission 0600 - owner read/write, nobody else has access\n      flag: 'w'\n    };\n    \n    fs.writeFile(this._filename, JSON.stringify(entries, null, 2), writeOptions, done);\n  },\n  \n  loadEntries: function (callback) {\n    var entries = [];\n    var err;\n    try {\n      var content = fs.readFileSync(this._filename);\n      content = utils.stripBOM(content);\n      if (!content) {\n        return callback(null, []);\n      }\n      entries = JSON.parse(content);\n      entries.forEach(function (entry) {\n        entry.expiresOn = new Date(entry.expiresOn);\n      });\n    } catch (ex) {\n      if (ex.code !== 'ENOENT') {\n        err = ex;\n      }\n    }\n    callback(err, entries);\n  },\n  \n  removeEntries: function (entriesToRemove, entriesToKeep, callback) {\n    this._save(entriesToKeep, callback);\n  },\n  \n  addEntries: function (newEntries, existingEntries, callback) {\n    var entries = existingEntries.concat(newEntries);\n    this._save(entries, callback);\n  },\n\n  clear: function (callback) {   \n    this._save([], callback); \n  }\n});\n\nmodule.exports = FileTokenStorage;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/authentication/token-cache.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar async = require('async');\n\n//Skip fields which aren't required for token acquisitions, but causing token\n//persisting issues, such as https://github.com/Azure/azure-xplat-cli/issues/2269\nvar fieldsOmittedFromCache = ['familyName', 'givenName', 'isUserIdDisplayable', 'tenantId'];\n/**\n * Constructs a new token cache that works with adal-node\n * @constructor\n */\nfunction TokenCache(tokenStorage) {\n  this._entries = null;\n  this._tokenStorage = tokenStorage;\n}\n\n_.extend(TokenCache.prototype, {\n  /**\n  * Load the cache entries. Does a lazy load,\n  * loads from OS on first request, otherwise\n  * returns in-memory copy.\n  *\n  * @param {function(err, Array)} callback callback\n  *                               receiving cache entries.\n  */\n  _loadEntries: function (callback) {\n    var self = this;\n    if (self._entries !== null) {\n      return callback(null, self._entries);\n    }\n    \n    self._tokenStorage.loadEntries(function (err, entries) {\n      if (!err) {\n        self._entries = entries;\n      }\n      self._normalize(entries, false);\n      callback(err, entries);\n    });\n  },\n  \n  _normalize: function (entries, removeUselessFields) {\n    entries.forEach(function (entry) {\n      if (entry.userId) {\n        entry.userId = entry.userId.toLowerCase();\n      }\n      if (removeUselessFields) {\n        fieldsOmittedFromCache.forEach(function (field) {\n          delete entry[field];\n        });\n      }\n    });\n  },\n  \n  isSecureCache: function () {\n    return this._tokenStorage.isSecureCache;\n  },\n  \n  /**\n   * Removes a collection of entries from the cache in a single batch operation.\n   * @param  {Array}   entries  An array of cache entries to remove.\n   * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\n   *                             first parameter.\n   */\n  remove: function remove(entries, callback) {\n    var self = this;\n    \n    //clone it so '_normalize' won't impact original cached entries\n    var clonedList = [];\n    entries.forEach(function(e){\n      clonedList.push(_.clone(e));\n    });\n    self._normalize(clonedList, true);\n    \n    function shouldKeep(entry) {\n      //Note, '_findWhere' doesn't do deep comparision, so exlcude fields with object type\n      var matched = _.findWhere(clonedList, _.omit(entry, ['expiresOn'].concat(fieldsOmittedFromCache)));\n      return (!matched);\n    }\n    \n    self._loadEntries(function (err, _entries) {\n      if (err) { return callback(err); }\n      \n      var grouped = _.groupBy(_entries, shouldKeep);\n      var entriesToRemove = grouped[false] || [];\n      var entriesToKeep = grouped[true] || [];\n      \n      self._tokenStorage.removeEntries(entriesToRemove, entriesToKeep, function (err) {\n        if (!err) {\n          self._entries = entriesToKeep;\n        }\n        callback(err);\n      });\n    });\n  },\n  \n  /**\n   * Clears a collection of entries from the cache in a single batch operation.\n   * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\n   *                             first parameter.\n   */\n  clear: function clear(callback) {\n    this._tokenStorage.clear(callback);\n  },\n  \n  /**\n   * Adds a collection of entries to the cache in a single batch operation.\n   * @param {Array}   entries  An array of entries to add to the cache.\n   * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\n   *                             first parameter.\n   */\n  add: function add(newEntries, callback) {\n    var self = this;\n    self._normalize(newEntries, true);\n    async.waterfall([\n      //load existing entries\n      function (cb) {\n        self._loadEntries(cb);\n      },\n\n      //clean up entries with same fields.\n      function (existingEntries, cb) {\n        //'self._entries' should be the same with existingEntries\n        async.eachSeries(newEntries, \n          function (e, cb2) {\n            var query = {\n              _clientId: e._clientId,\n              userId: e.userId,\n              _authority: e._authority\n            };\n            self.find(query, function (err, result) {\n              if (result && result.length !== 0) {\n                return self.remove(result, cb2);\n              }\n              return cb2(err);\n            });\n          },\n          function (err) { return cb(err); }\n        );\n      },\n\n      //add all newEntries\n      function (cb) {\n        self._tokenStorage.addEntries(newEntries, self._entries, function (err) {\n          if (err) return cb(err);\n          newEntries.forEach(function (entry) {\n            self._entries.push(entry);\n          });\n          return cb(null);\n        });\n      }\n    ],\n    function (err) {\n      return callback(err);\n    });\n  },\n  \n  /**\n   * Finds all entries in the cache that match all of the passed in values.\n   * @param  {object}   query    This object will be compared to each entry in the cache.  Any entries that\n   *                             match all of the values in this object will be returned.  All the values\n   *                             in the passed in object must match values in a potentialy returned object\n   *                             exactly.  The returned object may have more values than the passed in query\n   *                             object.\n   * @param  {TokenCacheFindCallback} callback\n   */\n  find: function find(query, callback) {\n    var self = this;\n    \n    self._normalize([query], true);\n    self._loadEntries(function (err, _entries) {\n      if (err) { return callback(err); }\n      var results = _.where(_entries, query);\n      callback(null, results);\n    });\n  }\n});\n\nmodule.exports = TokenCache;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/profile/environment.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar url = require('url');\nvar util = require('util');\n\nvar constants = require('../constants');\n\nvar $ = require('../utils').getLocaleString;\n\nvar DEFAULT_ENV_NAME = 'AzureCloud';\n\nfunction nulls(properties) {\n  return properties.reduce(function (acc, prop) { acc[prop] = null; return acc; }, {});\n}\n\nfunction Environment(envData) {\n  var self = this;\n\n  self.name = envData.name;\n  var values = envData;\n  _.defaults(values, nulls(_.pluck(Environment.parameters, 'name')));\n\n  Environment.parameters.forEach(function (param) {\n    Object.defineProperty(self, param.name, param.propertyDescriptor(self));\n  });\n\n  Object.defineProperties(self, {\n    isPublicEnvironment: {\n      enumerable: true,\n      configurable: false,\n      get: function () {\n        return _.chain(Environment.publicEnvironments).pluck('name').contains(this.name).value();\n      }\n    },\n\n    values: {\n      enumerable: false,\n      configurable: false,\n      get: function () { return values; }\n    }\n  });\n}\n\nfunction EnvironmentParameter(name, environmentVariable, description) {\n  this.name = name;\n  this.environmentVariable = environmentVariable;\n  this.description = $(description);\n}\n\n_.extend(EnvironmentParameter.prototype, {\n  propertyDescriptor: function (env) {\n    var self = this;\n    return {\n      enumerable: true,\n      configurable: false,\n      get: function () {\n        var val = process.env[self.environmentVariable] || env.values[self.name];\n        if (val === null) {\n          throw new Error(util.format(\n            $('The endpoint field %s is not defined in this environment.' +\n              ' Either this feature is not supported or the endpoint needs to be set using \\'azure account env set\\''),\n            self.name));\n        }\n        return val;\n      },\n      set: function (value) { this.values[self.name] = value; }\n    };\n  },\n});\n\nEnvironment.parameters = [\n  new EnvironmentParameter('portalUrl', 'AZURE_PORTAL_URL', 'the management portal URL'),\n  new EnvironmentParameter('publishingProfileUrl', 'AZURE_PUBLISHINGPROFILE_URL', 'the publish settings file URL'),\n  new EnvironmentParameter('managementEndpointUrl', 'AZURE_MANAGEMENTENDPOINT_URL', 'the management service endpoint'),\n  new EnvironmentParameter('resourceManagerEndpointUrl', 'AZURE_RESOURCEMANAGERENDPOINT_URL', 'the resource management endpoint'),\n  new EnvironmentParameter('sqlManagementEndpointUrl', 'AZURE_SQL_MANAGEMENTENDPOINT_URL', 'the sql server management endpoint for mobile commands'),\n  new EnvironmentParameter('sqlServerHostnameSuffix', 'AZURE_SQL_SERVER_HOSTNAME_SUFFIX', 'the dns suffix for sql servers'),\n  new EnvironmentParameter('activeDirectoryEndpointUrl', 'AZURE_ACTIVEDIRECTORY_ENDPOINT_URL', 'the Active Directory login endpoint'),\n  new EnvironmentParameter('activeDirectoryResourceId', 'AZURE_ACTIVEDIRECTORY_RESOURCE_ID', 'The resource ID to obtain AD tokens for'),\n  new EnvironmentParameter('galleryEndpointUrl', 'AZURE_GALLERY_ENDPOINT_URL', 'the template gallery endpoint'),\n  new EnvironmentParameter('activeDirectoryGraphResourceId', 'AZURE_ACTIVEDIRECTORY_GRAPH_RESOURCE_ID', 'the Active Directory resource ID'),\n  new EnvironmentParameter('activeDirectoryGraphApiVersion', 'AZURE_ACTIVEDIRECTORY_GRAPH_API_VERSION', 'the Active Directory api version'),\n  new EnvironmentParameter('storageEndpointSuffix', 'AZURE_STORAGE_ENDPOINT_SUFFIX', 'the endpoint suffix for storage accounts'),\n  new EnvironmentParameter('keyVaultDnsSuffix', 'AZURE_KEYVAULT_DNS_SUFFIX', 'the keyvault service dns suffix'),\n  new EnvironmentParameter('azureDataLakeStoreFileSystemEndpointSuffix', 'AZURE_DATALAKE_STORE_FILESYSTEM_DNS_SUFFIX', 'the data lake store filesystem service dns suffix'),\n  new EnvironmentParameter('azureDataLakeAnalyticsCatalogAndJobEndpointSuffix', 'AZURE_DATALAKE_ANALYTICS_JOB_CATALOG_DNS_SUFFIX', 'the data lake analytics job and catalog service dns suffix')\n];\n\nfunction addRealm(targetUrl, realm) {\n  if (realm) {\n    var urlObj = url.parse(targetUrl, true);\n    delete urlObj.search;\n    urlObj.query.whr = realm;\n    targetUrl = url.format(urlObj);\n  }\n  return targetUrl;\n}\n\n_.extend(Environment.prototype, {\n  getPortalUrl: function (realm) {\n    return addRealm(this.portalUrl, realm);\n  },\n\n  getPublishingProfileUrl: function (realm) {\n    return addRealm(this.publishingProfileUrl, realm);\n  },\n\n  toJSON: function () {\n    return _.extend({ name: this.name }, this.values);\n  },\n\n  getAuthConfig: function (tenantId, resourceId) {\n    if (!tenantId) {\n      tenantId = constants.AAD_COMMON_TENANT;\n    }\n    if (!resourceId) {\n      resourceId = this.activeDirectoryResourceId;\n    }\n    return {\n      authorityUrl: this.activeDirectoryEndpointUrl,\n      tenantId: tenantId,\n      resourceId: resourceId,\n      clientId: constants.XPLAT_CLI_CLIENT_ID\n    };\n  },\n\n  isDefaultEnv: function () {\n    return this.name === DEFAULT_ENV_NAME;\n  }\n});\n\nEnvironment.publicEnvironments = [\n  new Environment({\n    name: DEFAULT_ENV_NAME,\n    portalUrl: 'http://go.microsoft.com/fwlink/?LinkId=254433',\n    publishingProfileUrl: 'http://go.microsoft.com/fwlink/?LinkId=254432',\n    managementEndpointUrl: 'https://management.core.windows.net',\n    resourceManagerEndpointUrl: 'https://management.azure.com/',\n    sqlManagementEndpointUrl: 'https://management.core.windows.net:8443/',\n    sqlServerHostnameSuffix: '.database.windows.net',\n    galleryEndpointUrl: 'https://gallery.azure.com/',\n    activeDirectoryEndpointUrl: 'https://login.microsoftonline.com',\n    activeDirectoryResourceId: 'https://management.core.windows.net/',\n    activeDirectoryGraphResourceId: 'https://graph.windows.net/',\n    activeDirectoryGraphApiVersion: '2013-04-05',\n    storageEndpointSuffix: '.core.windows.net',\n    keyVaultDnsSuffix: '.vault.azure.net',\n    azureDataLakeStoreFileSystemEndpointSuffix: 'azuredatalakestore.net',\n    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: 'azuredatalakeanalytics.net'\n  }),\n  new Environment({\n    name: 'AzureChinaCloud',\n    portalUrl: 'http://go.microsoft.com/fwlink/?LinkId=301902',\n    publishingProfileUrl: 'http://go.microsoft.com/fwlink/?LinkID=301774',\n    managementEndpointUrl: 'https://management.core.chinacloudapi.cn',\n    resourceManagerEndpointUrl: 'https://management.chinacloudapi.cn',\n    sqlManagementEndpointUrl: 'https://management.core.chinacloudapi.cn:8443/',\n    sqlServerHostnameSuffix: '.database.chinacloudapi.cn',\n    galleryEndpointUrl: 'https://gallery.chinacloudapi.cn/',\n    activeDirectoryEndpointUrl: 'https://login.chinacloudapi.cn',\n    activeDirectoryResourceId: 'https://management.core.chinacloudapi.cn/',\n    activeDirectoryGraphResourceId: 'https://graph.chinacloudapi.cn/',\n    activeDirectoryGraphApiVersion: '2013-04-05',\n    storageEndpointSuffix: '.core.chinacloudapi.cn',\n    keyVaultDnsSuffix: '.vault.azure.cn',\n    // TODO: add dns suffixes for the china cloud for datalake store and datalake analytics once they are defined.\n    azureDataLakeStoreFileSystemEndpointSuffix: 'N/A',\n    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: 'N/A'\n  }),\n  new Environment({\n    name: 'AzureUSGovernment',\n    portalUrl: 'https://manage.windowsazure.us',\n    publishingProfileUrl: 'https://manage.windowsazure.us/publishsettings/index',\n    managementEndpointUrl: 'https://management.core.usgovcloudapi.net',\n    resourceManagerEndpointUrl: 'https://management.usgovcloudapi.net',\n    sqlManagementEndpointUrl: 'https://management.core.usgovcloudapi.net:8443/',\n    sqlServerHostnameSuffix: '.database.usgovcloudapi.net',\n    galleryEndpointUrl: 'https://gallery.usgovcloudapi.net/',\n    activeDirectoryEndpointUrl: 'https://login-us.microsoftonline.com',\n    activeDirectoryResourceId: 'https://management.core.usgovcloudapi.net/',\n    activeDirectoryGraphResourceId: 'https://graph.windows.net/',\n    activeDirectoryGraphApiVersion: '2013-04-05',\n    storageEndpointSuffix: '.core.usgovcloudapi.net',\n    keyVaultDnsSuffix: '.vault.usgovcloudapi.net',\n    // TODO: add dns suffixes for the US government for datalake store and datalake analytics once they are defined.\n    azureDataLakeStoreFileSystemEndpointSuffix: 'N/A',\n    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: 'N/A'\n  }),\n  new Environment({\n    name: 'AzureGermanCloud',\n    portalUrl: 'http://portal.microsoftazure.de/',\n    publishingProfileUrl: 'https://manage.microsoftazure.de/publishsettings/index',\n    managementEndpointUrl: 'https://management.core.cloudapi.de',\n    resourceManagerEndpointUrl: 'https://management.microsoftazure.de',\n    sqlManagementEndpointUrl: 'https://management.core.cloudapi.de:8443/',\n    sqlServerHostnameSuffix: '.database.cloudapi.de',\n    galleryEndpointUrl: 'https://gallery.cloudapi.de/',\n    activeDirectoryEndpointUrl: 'https://login.microsoftonline.de',\n    activeDirectoryResourceId: 'https://management.core.cloudapi.de/',\n    activeDirectoryGraphResourceId: 'https://graph.cloudapi.de/',\n    activeDirectoryGraphApiVersion: '2013-04-05',\n    storageEndpointSuffix: '.core.cloudapi.de',\n    keyVaultDnsSuffix: '.vault.microsoftazure.de',\n    // TODO: add dns suffixes for the US government for datalake store and datalake analytics once they are defined.\n    azureDataLakeStoreFileSystemEndpointSuffix: 'N/A',\n    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: 'N/A'\n  })\n];\n\nmodule.exports = Environment;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/profile/subscription.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar _ = require('underscore');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar azureCommon = require('azure-common');\nvar log = require('../logging');\nvar utils = require('../utils');\nvar $ = utils.getLocaleString;\n\nfunction Subscription(subscriptionData, environment) {\n  this.id = subscriptionData.id;\n  if (subscriptionData.managementCertificate) {\n    this.managementCertificate = subscriptionData.managementCertificate;\n  }\n\n  this.values = {};\n\n  _.extend(this, _.omit(subscriptionData, 'environmentName', 'username'));\n\n  this.isDefault = this.isDefault || false;\n  this.environment = environment;\n\n  if (_.isUndefined(subscriptionData.user)) {\n    if (subscriptionData.username) {\n      this.user = {\n        name: subscriptionData.username,\n        tenant: null,\n        type: 'user'\n      };\n    }\n  }\n\n  this.registeredProviders = subscriptionData.registeredProviders || [];\n}\n\nutil.inherits(Subscription, EventEmitter);\n\nfunction getField(fieldName) {\n  /*jshint validthis: true */\n  return this.values[fieldName] || this.environment[fieldName];\n}\n\nfunction setField(fieldName, value) {\n  /*jshint validthis: true */\n  this.values[fieldName] = value;\n}\n\nfunction descriptorForField(fieldName) {\n  return {\n    enumerable: true,\n    configurable: false,\n    get: function () { return getField.call(this, fieldName); },\n    set: function (value) { return setField.call(this, fieldName, value); }\n  };\n}\n\nfunction descriptorsFor() {\n  return _.object(arguments, _.map(arguments, descriptorForField));\n}\n\nObject.defineProperties(Subscription.prototype,\n  descriptorsFor(\n    'managementEndpointUrl',\n    'resourceManagerEndpointUrl',\n    'sqlManagementEndpointUrl',\n    'hostNameSuffix',\n    'sqlServerHostnameSuffix',\n    'activeDirectoryEndpointUrl',\n    'storageEndpoint',\n    'galleryEndpointUrl',\n    'activeDirectoryGraphResourceId',\n    'keyVaultDnsSuffix',\n    'azureDataLakeStoreFileSystemEndpointSuffix',\n    'azureDataLakeAnalyticsCatalogAndJobEndpointSuffix'\n    )\n  );\n\n_.extend(Subscription.prototype, {\n  /**\n  * Update this subscription object with values from the\n  * given subscription.\n  *\n  * @param {object} subscription Other subscription object to pull values from.\n  *\n  * @returns {object} this\n  */\n  updateFrom: function (subscription) {\n    _.extend(this.values, subscription.values);\n\n    if (subscription.user) {\n      this.user = subscription.user;\n    }\n\n    if (subscription.managementCertificate) {\n      this.managementCertificate = subscription.managementCertificate;\n    }\n    \n    if (subscription.tenantId) {\n      this.tenantId = subscription.tenantId;\n    }\n    \n    if (subscription.state) {\n      this.state = subscription.state;\n    }\n    \n    return this;\n  },\n\n  exportManagementCertificate: function (outputFile) {\n    if (!this.managementCertificate) {\n      throw new Error($('This subscription does not use a management certificate'));\n    }\n    var pemData = this.managementCertificate.key + this.managementCertificate.cert;\n    utils.writeFileSyncMode(outputFile, pemData, 'utf8');\n  },\n\n  _createCredentials: function (resourceId) {\n    var cred;\n    var authConfig = this.environment.getAuthConfig(this.tenantId, resourceId);\n    if (this.user) {\n      switch (this.user.type) {\n        case 'user':\n          cred = new (require('../authentication/adalAuthForUser').UserTokenCredentials)(authConfig, this.user.name);\n          break;\n\n        case 'servicePrincipal':\n          authConfig.tenantId = this.tenantId;\n          cred = new (require('../authentication/adalAuthForServicePrincipal').ServicePrincipalTokenCredentials)(authConfig, this.user.name);\n          break;\n\n        default:\n          throw new Error($('Unknown user type, cannot create credentials'));\n      }\n      cred.subscriptionId = this.id;\n      return cred;\n    } else if (this.managementCertificate) {\n      return new azureCommon.CertificateCloudCredentials({\n        subscriptionId: this.id,\n        cert: this.managementCertificate.cert,\n        key: this.managementCertificate.key\n      });\n    }\n\n    throw new Error($('No Azure AD credentials or management certificate, cannot create credentials'));\n  },\n  \n  wasCreatedFromPublishSettingsFile: function () {\n    return this.managementCertificate && !this.user;\n  },\n\n  toJSON: function () {\n    return _.extend(\n      _.pick(this,\n        'id', 'name', 'user', 'managementCertificate', 'accessToken', 'tenantId', \n        'state', 'isDefault', 'registeredProviders'),\n      { environmentName: this.environment.name },\n      this.values);\n  },\n\n  isAsmProviderRegistered: function (providerName) {\n    var result = false;\n    if (this.registeredProviders.some(function (item) {\n      return utils.ignoreCaseEquals(item, providerName);\n    })) {\n      result = true;\n    }\n    return result;\n  },\n\n  registerAsmProvider: function (providerName, callback) {\n    var self = this;\n    if (!self.isAsmProviderRegistered(providerName)) {\n      var client = utils.createManagementClient(self);\n      log.verbose(util.format($('Registering resource %s with subscription %s'), providerName, self.id));\n      client.subscriptions.registerResource(providerName, function (err) {\n        if (err) {\n          // 409 - conflict means the resource is already registered. Not an error\n          if (err.statusCode === 409) {\n            log.silly(util.format($('Resource %s is already registered'), providerName));\n          } else {\n            return callback(err);\n          }\n        }\n        self.registeredProviders.push(providerName);\n        self.emit('updated');\n        callback();\n      });\n    } else {\n      callback();\n    }\n  },\n\n  registerArmProvider: function (namespace, waitForComplete, callback) {\n    var self = this;\n    var client = utils.createResourceClient(self);\n    var numRetries = 5;\n\n    log.verbose(util.format($('Registering resource namespace %s with subscription %s'), namespace, self.id));\n    client.providers.register(namespace, function (err) {\n      if (err || !waitForComplete) {\n        return callback(err);\n      }\n      self._waitForRegistrationComplete(client, true, numRetries, namespace, callback);\n    });\n  },\n\n  unRegisterArmProvider: function (namespace, callback) {\n    var self = this;\n    var client = utils.createResourceClient(self);\n    //\"Unregister\" is less common and we care less for the result,\n    //so we retry less times comparing with \"register\" command.\n    var numRetries = 3; \n\n    log.verbose(util.format($('Un-registering resource namespace %s with subscription %s'), namespace, self.id));\n    client.providers.unregister(namespace, function (err) {\n      if (err) {\n        log.error(util.format($('Un-registering resource namespace %s failed'), namespace));\n        return callback(err);\n      }\n      self._waitForRegistrationComplete(client, false, numRetries, namespace, function (err) {\n        if (err) {\n          log.warn(util.format($('Unregistration is still ongoing. You can execute \\'azure provider show\\' to monitor the status')));\n        }\n        callback();\n      });\n    });\n  },\n  \n  /**\n  * Waits for Registration or Uregistration to complete\n  *\n  * @param {object} client - The ARM Resource Management Client\n  * @param {boolean} regOrUnreg - A boolean value, true - register, false - unregister\n  * @param {number} retriesLeft - An integer specifying the number of times to retry\n  * @param {string} namespace - the namespace/provider for which the registration status needs to be polled \n  * @param {function} callback\n  */\n  _waitForRegistrationComplete: function (client, regOrUnreg, retriesLeft, namespace, cb) {\n    var pollIntervalInMS = 10 * 1000;\n    var self = this;\n    var action = regOrUnreg ? 'Registration' : 'Unregistration';\n    var state = regOrUnreg ? 'Registered' : 'Unregistered';\n\n    if (retriesLeft === 0) {\n      return cb(util.format($('Namespace %s %s took too long to complete'), namespace, action));\n    }\n    \n    client.providers.get(namespace, function (err, result) {\n      if (!err) {\n        if (utils.ignoreCaseEquals(result.registrationState, state)) {\n          log.verbose(util.format($('%s of resource provider %s completed'), action, namespace));\n          return cb();\n        }\n      }\n      setTimeout(function () { self._waitForRegistrationComplete(client, regOrUnreg, retriesLeft - 1, namespace, cb); }, pollIntervalInMS);\n    });\n  }\n});\n\nmodule.exports = Subscription;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/profile/publishSettings.js":"/**\n* Copyright (c) Microsoft.  All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nvar fs = require('fs');\nvar xml2js = require('xml2js');\n\nvar keyFiles = require('../keyFiles');\nvar pfx2pem = require('../certificates/pkcs').pfx2pem;\nvar utils = require('../utils');\n\nvar $ = utils.getLocaleString;\n\nfunction readFileContents(filePath) {\n  var readBuffer = fs.readFileSync(filePath);\n  var publishSettings;\n  var parser = new xml2js.Parser();\n  parser.parseString(readBuffer, function (err, result) {\n    if (!err) {\n      publishSettings = result;\n    } else {\n      throw err;\n    }\n  });\n  return publishSettings;\n}\n\nfunction parseManagementCert(publishSettingsCert) {\n  var pfx = new Buffer(publishSettingsCert, 'base64');\n  var pem = pfx2pem(pfx).toString();\n  return keyFiles.readFromString(pem);\n}\n\nfunction subscriptionsFromContents(xmlContent) {\n  if (!xmlContent.PublishProfile ||\n    (xmlContent.PublishProfile['@'] &&\n      !xmlContent.PublishProfile['@'].ManagementCertificate &&\n      xmlContent.PublishProfile['@'].SchemaVersion !== '2.0')) {\n    throw new Error($('Invalid publishSettings file. Use \"azure account download\" to download publishing credentials.'));\n  }\n\n  var attribs = xmlContent.PublishProfile['@'];\n  var subs = xmlContent.PublishProfile.Subscription;\n  if (!subs) {\n    subs = [];\n  }\n\n   else if (!subs[0]) {\n    subs = [ subs ];\n  }\n\n  subs.forEach(function (sub) {\n    if (sub['@']) {\n      sub.id = sub['@'].Id;\n      sub.name = sub['@'].Name;\n      sub.managementCertificate = sub['@'].ManagementCertificate;\n      sub.managementEndpointUrl = sub['@'].ServiceManagementUrl;\n\n      delete sub['@'];\n    }\n\n    if (attribs) {\n      if (attribs.ManagementCertificate && !sub.managementCertificate) {\n        sub.managementCertificate = attribs.ManagementCertificate;\n      }\n\n      if (attribs.Url && !sub.ServiceManagementUrl) {\n        sub.managementEndpointUrl = attribs.Url;\n      }\n    }\n  });\n\n  subs.forEach(function (s) { s.managementCertificate = parseManagementCert(s.managementCertificate); } );\n  return subs;\n}\n\nfunction importPublishSettings(filePath) {\n  var xml = readFileContents(filePath);\n  return subscriptionsFromContents(xml);\n}\n\nexports.import = importPublishSettings;\n\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/keyFiles.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n/**\n * Functions to work with key and certificate files\n */\n\nvar fs = require('fs');\nvar utils = require('./utils');\n\nvar KEY_PATT = /(-+BEGIN RSA PRIVATE KEY-+)(\\n\\r?|\\r\\n?)([A-Za-z0-9\\+\\/\\n\\r]+\\=*)(\\n\\r?|\\r\\n?)(-+END RSA PRIVATE KEY-+)/;\nvar CERT_PATT = /(-+BEGIN CERTIFICATE-+)(\\n\\r?|\\r\\n?)([A-Za-z0-9\\+\\/\\n\\r]+\\=*)(\\n\\r?|\\r\\n?)(-+END CERTIFICATE-+)/;\n\nexports.readFromFile = function readFromFile(fileName) {\n  // other parameters are optional\n  var data;\n  try {\n    data = fs.readFileSync(fileName, 'utf8');\n  } catch(e) {\n    throw new Error('No account information found. Please import credentials using \"azure account import <file>\".');\n  }\n  return exports.readFromString(data);\n};\n\nexports.readFromString = function readFromString(data) {\n  var ret = {};\n  var matchKey = data.match(KEY_PATT);\n  if (matchKey) {\n    ret.key = matchKey[1] + '\\n' + matchKey[3] + '\\n' + matchKey[5] + '\\n';\n  }\n\n  var matchCert = data.match(CERT_PATT);\n  if (matchCert) {\n    ret.cert = matchCert[1] + '\\n' + matchCert[3] + '\\n' + matchCert[5] + '\\n';\n  }\n\n  return ret;\n};\n\nexports.writeToFile = function writeToFile(fileName, keyCertData) {\n  utils.writeFileSyncMode(fileName, exports.writeToString(keyCertData), 'utf8');\n};\n\nexports.writeToString = function writeToString(keyCertData) {\n  return (keyCertData.key || '') + (keyCertData.cert || '');\n};\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/certificates/pkcs.js":"// \n// Copyright (c) Microsoft and contributors.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// \n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\nvar der = require('./der');\nvar util = require('util');\nvar assert = require('assert');\nvar crypto = require('crypto');\n\nvar Decoder = der.Decoder;\n\nvar Pkcs = {\n  PfxDecoder: PfxDecoder,\n  oid: {\n    '1.2.840.113549.1':'pkcs',\n    '1.2.840.113549.1.1':'pkcs1',\n    '1.2.840.113549.1.1.1':'RSA encryption',\n    '1.2.840.113549.1.7':'pkcs7',\n    '1.2.840.113549.1.7.1':'data',\n    '1.2.840.113549.1.7.6':'encryptedData',\n    '1.2.840.113549.1.9':'pkcs9',\n    '1.2.840.113549.1.9.20':'friendlyName',\n    '1.2.840.113549.1.9.21':'localKeyId',\n    '1.2.840.113549.1.9.22':'certTypes',\n    '1.2.840.113549.1.9.22.1':'x509Certificate',\n    '1.2.840.113549.1.12':'pkcs12',\n    '1.2.840.113549.1.12.1':'Password-Based Encryption identifiers',\n    '1.2.840.113549.1.12.1.3':'pbeWithSHAAnd3-KeyTripleDES-CBC',\n    '1.2.840.113549.1.12.1.6':'pbeWithSHAAnd40BitRC2-CBC',\n    '1.2.840.113549.1.12.10.1':'Bag Types',\n    '1.2.840.113549.1.12.10.1.2':'pkcs-8ShroudedKeyBag',\n    '1.2.840.113549.1.12.10.1.3':'certBag',\n    '1.3.6.1.4.1.311.17.1':'pkcs-12-key-provider-name-attr'\n  },\n\n  pfx2pem: pfx2pem\n};\n\n\nfunction pfx2pem(buffer) {\n  var pem = '';\n\n  var decoder = new PfxDecoder();\n  decoder.on('key', function (key) {\n    pem = pem +\n    '-----BEGIN RSA PRIVATE KEY-----\\r\\n' +\n    split(key.buffer.toString('base64')) + '\\r\\n' +\n    '-----END RSA PRIVATE KEY-----\\r\\n';\n  });\n  decoder.on('cert', function (cert) {\n    pem = pem +\n    '-----BEGIN CERTIFICATE-----\\r\\n' +\n    split(cert.buffer.toString('base64')) + '\\r\\n' +\n    '-----END CERTIFICATE-----\\r\\n';\n  });\n\n  decoder.parse(buffer);\n\n  function split(text) {\n    var index = 0;\n    var result = '';\n    while (index + 64 < text.length) {\n      result = result + text.substring(index, index + 64) + '\\r\\n';\n      index += 64;\n    }\n    return result + text.substring(index);\n  }\n\n  return new Buffer(pem);\n}\n\n\nfunction PfxDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var pdu = new PfxPduDecoder();\n\n  self.on('element', function(element) {\n    pdu.parse(element.buffer);\n  });\n\n  pdu.on('cert', function(cert) {\n    self.emit('cert', cert);\n  });\n\n  pdu.on('key', function(key) {\n    self.emit('key', key);\n  });\n}\n\nutil.inherits(PfxDecoder, Decoder);\n\nfunction PfxPduDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var authSafe = new PfxContentInfoDecoder();\n  var authSafeItems = new PfxContentBagDecoder();\n  var safeBag = new PfxSafeBagDecoder();\n\n  self.on('end', function(elements) {\n    authSafe.parse(elements[1].buffer);\n  });\n\n  authSafe.on('data', function(data) {\n    authSafeItems.parse(data);\n  });\n\n  authSafeItems.on('data', function(data) {\n    safeBag.parse(data);\n  });\n\n  safeBag.on('cert', function(cert) {\n    self.emit('cert', cert);\n  });\n\n  safeBag.on('key', function(key) {\n    self.emit('key', key);\n  });\n}\n\nutil.inherits(PfxPduDecoder, Decoder);\n\nfunction PfxContentBagDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var itemDecoder = new PfxContentInfoDecoder();\n  itemDecoder.on('data', function(data) {\n    self.emit('data', data);\n  });\n\n  self.on('element', function(element) {\n    assert.equal(element.tag, der.SEQUENCE);\n\n    itemDecoder.parse(element.buffer);\n  });\n}\n\nutil.inherits(PfxContentBagDecoder, Decoder);\n\nfunction PfxContentInfoDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var generic = new Decoder();\n  var encryptedData = new PfxEncryptedDataDecoder();\n\n  encryptedData.on('data', function(data) {\n    self.emit('data', data);\n  });\n\n  self.on('end', function(elements) {\n    assert.equal(elements[0].tag, der.OBJECT_IDENTIFIER);\n    var oid = elements[0].value;\n\n    if (Pkcs.oid[oid] == 'data') {\n      assert.equal(elements.length, 2);\n      assert.equal(elements[1].tag, der.CONTEXT_CONSTRUCTED_0);\n      elements = generic.parse(elements[1].buffer);\n\n      assert.equal(elements.length, 1);\n      assert.equal(elements[0].tag, der.OCTET_STRING);\n      elements = generic.parse(elements[0].buffer);\n\n      for(var index = 0; index != elements.length; ++index) {\n        assert.equal(elements[index].tag, der.SEQUENCE);\n        self.emit('data', elements[index].buffer);\n      }\n    } else if (Pkcs.oid[oid] == 'encryptedData') {\n      assert.equal(elements[1].tag, der.CONTEXT_CONSTRUCTED_0);\n      elements = generic.parse(elements[1].buffer);\n\n      assert.equal(elements.length, 1);\n      assert.equal(elements[0].tag, der.SEQUENCE);\n\n      elements = generic.parse(elements[0].buffer);\n      assert.equal(elements.length, 2);\n      assert.equal(elements[0].tag, der.INTEGER);\n      assert.equal(elements[0].value, 0);\n      assert.equal(elements[1].tag, der.SEQUENCE);\n\n      encryptedData.parse(elements[1].buffer);\n    } else {\n      throw new Error('Unknown AuthenticatedSafe oid ' + oid);\n    }\n  });\n}\n\nutil.inherits(PfxContentInfoDecoder, Decoder);\n\nfunction PfxEncryptedDataDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var algorithmDecoder = new PfxAlgorithmDecoder();\n  var generic = new Decoder();\n\n  self.on('end', function(elements) {\n    assert.equal(elements.length, 3);\n    assert.equal(elements[0].tag, der.OBJECT_IDENTIFIER);\n    assert.equal(elements[1].tag, der.SEQUENCE);\n    assert.equal(elements[2].tag, der.CONTEXT_PRIMATIVE_0);\n\n    var algorithm = algorithmDecoder.parse(elements[1].buffer);\n    var cipher = algorithm.createCipher(null);\n    var data1 = cipher.update(elements[2].buffer);\n    var data2 = cipher.final();\n\n    var data = null;\n    if (Buffer.concat) {\n      var data1buf = new Buffer(data1, 'binary');\n      var data2buf = new Buffer(data2, 'binary');\n      data = Buffer.concat([data1buf, data2buf]);\n    } else {\n      data = new Buffer(data1 + data2, 'binary');\n    }\n\n    elements = generic.parse(data);\n\n    for(var index = 0; index != elements.length; ++index) {\n      assert.equal(elements[index].tag, der.SEQUENCE);\n      self.emit('data', elements[index].buffer);\n    }\n  });\n}\n\nutil.inherits(PfxEncryptedDataDecoder, Decoder);\n\nfunction PfxAlgorithmDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var generic = new Decoder();\n\n  self.on('end', function(elements) {\n    assert.equal(elements.length, 2);\n    assert.equal(elements[0].tag, der.OBJECT_IDENTIFIER);\n    assert.equal(elements[1].tag, der.SEQUENCE);\n\n    var args = generic.parse(elements[1].buffer);\n    assert.equal(args.length, 2);\n    assert.equal(args[0].tag, der.OCTET_STRING);\n    assert.equal(args[1].tag, der.INTEGER);\n\n    var algorithmOid = elements[0].value;\n    var salt = args[0].value;\n    var iterations = args[1].value;\n\n    var algorithmName = Pkcs.oid[algorithmOid];\n    if (algorithmName == 'pbeWithSHAAnd40BitRC2-CBC') {\n      elements.createCipher = function(password) {\n        var key = createPkcs12Info(password, salt, 5, iterations, 1);\n        var iv = createPkcs12Info(password, salt, 8, iterations, 2);\n        return crypto.createDecipheriv('rc2-40-cbc', key, iv);\n      };\n    } else if (algorithmName == 'pbeWithSHAAnd3-KeyTripleDES-CBC') {\n      elements.createCipher = function(password) {\n        var key = createPkcs12Info(password, salt, 24, iterations, 1);\n        var iv = createPkcs12Info(password, salt, 8, iterations, 2);\n        return crypto.createDecipheriv('des-ede3-cbc', key, iv);\n      };\n    } else {\n      throw new Error('Unknown algorithmId ' + algorithmOid);\n    }\n  });\n}\n\nutil.inherits(PfxAlgorithmDecoder, Decoder);\n\nfunction PfxSafeBagDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var generic = new Decoder();\n  var pkcs8ShroudedKeyBag = new PfxPkcs8ShroudedKeyBagDecoder();\n  var certBag = new PfxCertBagDecoder();\n  certBag.on('cert', function(cert){self.emit('cert', cert);});\n  pkcs8ShroudedKeyBag.on('key', function(key){self.emit('key', key);});\n\n  self.on('element', function(element) {\n    assert.equal(element.tag, der.SEQUENCE);\n\n    var elements = generic.parse(element.buffer);\n    assert.equal(elements[0].tag, der.OBJECT_IDENTIFIER);\n    var bagId = elements[0].value;\n    if (Pkcs.oid[bagId] == 'pkcs-8ShroudedKeyBag') {\n      assert.equal(elements[1].tag, der.CONTEXT_CONSTRUCTED_0);\n      elements = generic.parse(elements[1].buffer);\n\n      assert.equal(elements[0].tag, der.SEQUENCE);\n      pkcs8ShroudedKeyBag.parse(elements[0].buffer);\n    } else if (Pkcs.oid[bagId] == 'certBag') {\n      assert.equal(elements[1].tag, der.CONTEXT_CONSTRUCTED_0);\n      elements = generic.parse(elements[1].buffer);\n\n      assert.equal(elements[0].tag, der.SEQUENCE);\n      certBag.parse(elements[0].buffer);\n    } else {\n      throw new Error('Unknown SafeBag bagId ' + bagId);\n    }\n  });\n}\n\nutil.inherits(PfxSafeBagDecoder, Decoder);\n\nfunction PfxPkcs8ShroudedKeyBagDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var generic = new Decoder();\n  var algorithmDecoder = new PfxAlgorithmDecoder();\n\n  self.on('end', function(elements) {\n    assert.equal(elements.length, 2);\n    assert.equal(elements[0].tag, der.SEQUENCE);\n    assert.equal(elements[1].tag, der.OCTET_STRING);\n\n    var algorithm = algorithmDecoder.parse(elements[0].buffer);\n    var cipher = algorithm.createCipher(null);\n    var data1 = cipher.update(elements[1].buffer);\n    var data2 = cipher.final();\n\n    var data = null;\n    if (Buffer.concat) {\n      var data1buf = new Buffer(data1, 'binary');\n      var data2buf = new Buffer(data2, 'binary');\n      data = Buffer.concat([data1buf, data2buf]);\n    } else {\n      data = new Buffer(data1 + data2, 'binary');\n    }\n\n    elements = generic.parse(data);\n\n    for(var index = 0; index != elements.length; ++index) {\n      assert.equal(elements[index].tag, der.SEQUENCE);\n\n      var fields = generic.parse(elements[index].buffer);\n      assert.equal(fields.length, 3);\n      assert.equal(fields[0].tag, der.INTEGER);\n      assert.equal(fields[1].tag, der.SEQUENCE);\n      fields[1].fields = generic.parse(fields[1].buffer);\n      assert.equal(fields[1].fields[0].tag, der.OBJECT_IDENTIFIER);\n      assert.equal(fields[2].tag, der.OCTET_STRING);\n\n      self.emit('key', {\n        type: fields[1].fields[0].value,\n        buffer: fields[2].buffer\n      });\n    }\n  });\n}\n\nutil.inherits(PfxPkcs8ShroudedKeyBagDecoder, Decoder);\n\nfunction PfxCertBagDecoder() {\n  var self = this;\n  Decoder.call(self);\n\n  var generic = new Decoder();\n\n  self.on('end', function(elements) {\n    assert.equal(elements[0].tag, der.OBJECT_IDENTIFIER);\n    var certId = elements[0].value;\n    if (Pkcs.oid[certId] == 'x509Certificate') {\n      assert.equal(elements[1].tag, der.CONTEXT_CONSTRUCTED_0);\n      elements = generic.parse(elements[1].buffer);\n\n      assert.equal(elements[0].tag, der.OCTET_STRING);\n      self.emit('cert', {\n        type: certId,\n        buffer: elements[0].buffer\n      });\n    } else {\n      throw new Error('Unknown CertBag certId ' + certId);\n    }\n  });\n}\n\nutil.inherits(PfxCertBagDecoder, Decoder);\n\nfunction createPkcs12Info(password, salt, keyLength, iterations, id) {\n  var digestLength = 20; // sha-1 digest size constant\n  var inputBytes = 64; // pkcs12 constant for sha-1\n\n  var idString = new Buffer(inputBytes);\n  for(var index = 0; index != idString.length; ++index) {\n    idString[index] = id;\n  }\n\n  var saltString = new Buffer(strangeLength(salt.length, inputBytes));\n  fillBuffer(salt, saltString);\n\n  var passwordString = null;\n  if (password === null || password.length === 0) {\n    passwordString = new Buffer(0);\n  } else {\n    passwordString = new Buffer(strangeLength(password.length, inputBytes));\n    fillBuffer(password, passwordString);\n  }\n\n  var inputString = new Buffer(saltString.length + passwordString.length);\n  saltString.copy(inputString);\n  passwordString.copy(inputString, saltString.length);\n\n  var blocks = strangeLength(keyLength, digestLength) / digestLength;\n\n  var outputString = new Buffer(digestLength);\n  var holdString = new Buffer(inputBytes);\n  var dataString = new Buffer(blocks * digestLength);\n\n  var offset = 0;\n  for(var block = 0; block != blocks; ++block) {\n    outputString = digestIterations(idString, inputString, iterations);\n    outputString.copy(dataString, offset);\n    offset += outputString.length;\n\n    if (block != blocks - 1) {\n      fillBuffer(outputString, holdString);\n      createInputString(inputString, holdString, holdString);\n    }\n  }\n\n  var info = new Buffer(keyLength);\n  dataString.copy(info, 0, 0, keyLength);\n  return info;\n}\n\nfunction digestIterations(idString, inputString, iterations) {\n  var hash = crypto.createHash('sha1');\n  hash.update(idString);\n  hash.update(inputString);\n  //    console.log('Digest D (length %d):', idString.length);\n  //   console.log(idString);\n  //   console.log('Digest I (length %d):', inputString.length);\n  //   console.log(inputString);\n  var outputString = new Buffer(hash.digest('base64'),'base64');\n  for(var iteration = 1; iteration != iterations; ++iteration) {\n    hash = crypto.createHash('sha1');\n    hash.update(outputString);\n    outputString = new Buffer(hash.digest('base64'), 'base64');\n  }\n  //    console.log(outputString);\n  return outputString;\n}\n\nfunction createInputString(oldInput, addedInput) {\n  var inputSize = addedInput.length;\n  var passes = (oldInput.length / inputSize) >> 0;\n  var offset = 0;\n\n  for (var pass = 0; pass != passes; ++pass) {\n    var carry = 1;\n    for (var scan = 0; scan != inputSize; ++scan) {\n      var index = inputSize - scan - 1;\n      var value = oldInput[index + offset] + addedInput[index] + carry;\n      oldInput[index + offset] = value & 0xff;\n      carry = value >> 8;\n    }\n    offset += inputSize;\n  }\n}\n\nfunction strangeLength(length, blockSize) {\n  return blockSize * (((length+blockSize-1)/blockSize) >> 0);\n}\n\nfunction fillBuffer(source, target) {\n  var sourceLength = source.length;\n  var targetLength = target.length;\n  var targetStart = 0;\n\n  while (targetStart + sourceLength <= targetLength) {\n    source.copy(target, targetStart);\n    targetStart += sourceLength;\n  }\n\n  // console.log('source.copy %d %d', targetStart, targetLength);\n  if (targetLength != targetStart) {\n    source.copy(target, targetStart, 0, targetLength - targetStart);\n  }\n\n  //console.log('fillBuffer');\n  //console.log(source);\n  //console.log(target);\n}\n\nexports = module.exports = Pkcs;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/certificates/der.js":"// \n// Copyright (c) Microsoft and contributors.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// \n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\n\nvar util = require('util');\nvar EventEmitter = require( 'events' ).EventEmitter;\n\nvar Der = {\n  Decoder: Decoder,\n  Formatter: Formatter,\n\n  INTEGER: 'UNIVERSAL-primative-2',\n  BIT_STRING: 'UNIVERSAL-primative-3',\n  OCTET_STRING: 'UNIVERSAL-primative-4',\n  OBJECT_IDENTIFIER: 'UNIVERSAL-primative-6',\n  SEQUENCE: 'UNIVERSAL-constructed-10',\n  BMPString: 'UNIVERSAL-primative-1e',\n  CONTEXT_CONSTRUCTED_0: 'context-constructed-0',\n  CONTEXT_PRIMATIVE_0: 'context-primative-0',\n\n  dumpBuffer: dumpBuffer\n};\n\nfunction Decoder(options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.formatter = options.formatter || Der.defaultFormatter;\n}\n\nutil.inherits(Decoder, EventEmitter);\n\nDecoder.prototype.parse = function(buffer) {\n  var cumulative = [];\n  var cursor = new Cursor(buffer);\n  while (cursor) {\n    var next = cursor.next();\n\n    this.formatter.format(next.element);\n    this.emit('element', next.element);\n    cumulative.push(next.element);\n\n    cursor = next.cursor;\n  }\n\n  this.emit('end', cumulative);\n  return cumulative;\n};\n\nDecoder.prototype.verify = function(message, actual, expected) {\n  var passed = true;\n  if (arguments.length == 2) {\n    passed = actual;\n  } else {\n    passed = actual == expected;\n  }\n  if (!passed) {\n    throw new Error(message);\n  }\n};\n\nfunction Cursor(buffer) {\n  this.buffer = buffer;\n}\n\nCursor.prototype.next = function() {\n  var element = {};\n\n  var buffer = this.buffer;\n  var offset = 0;\n  var type = buffer[offset++];\n\n\n  element.tagClass = (type >> 6) & 0x03;\n  element.tagConstructed = (type >> 5) & 0x01;\n  var tagNumber = (type >> 0) & 0x1f;\n  if (tagNumber == 0x15) {\n    tagNumber = 0;\n    var tagNumberLast = buffer[offset++];\n    while(tagNumberLast & 0x80) {\n      tagNumber = (tagNumber << 7) + (tagNumberLast & 0x1f);\n      tagNumberLast = buffer[offset++];\n    }\n    tagNumber = (tagNumber << 7) + tagNumberLast;\n  }\n  element.tagNumber = tagNumber;\n\n  element.tag =\n  ['UNIVERSAL', 'APPLICATION', 'context', 'PRIVATE'][element.tagClass] +\n  ['-primative-','-constructed-'][element.tagConstructed] +\n  element.tagNumber.toString(16);\n\n  var length = buffer[offset++];\n  if ((length & 0x80) == 0x80 ) {\n    var lengthBytes = length & 0x7f;\n    length = 0;\n    while(lengthBytes--) {\n      length = length * 0x100 + buffer[offset++];\n    }\n  }\n  element.length = length;\n\n  if (length < 0) {\n    throw new Error('oob');\n  }\n\n  element.buffer = buffer.slice(offset, offset + length);\n  var slice1 = buffer.slice(offset + length);\n\n  var result = {element: element};\n  if (slice1.length) {\n    result.cursor = new Cursor(slice1);\n  }\n  return result;\n};\n\nfunction Formatter() {\n  EventEmitter.call(this);\n}\n\nutil.inherits(Formatter, EventEmitter);\n\n\nFormatter.prototype.format = function(element) {\n  this.emit(element.tag, element);\n};\n\nDer.defaultFormatter = new Formatter();\n\nDer.defaultFormatter.on(Der.INTEGER, function(element) {\n  element.value = 0;\n  for(var offset = 0; offset != element.buffer.length; ++offset) {\n    element.value = (element.value << 8) + element.buffer[offset];\n  }\n});\n\nDer.defaultFormatter.on(Der.OBJECT_IDENTIFIER, function(element) {\n  var values = [0];\n  var scan = element.buffer.length;\n  var offset = 0;\n  var cumulative = 0;\n  while (scan--) {\n    var octet = element.buffer[offset++];\n    if (octet & 0x80) {\n      cumulative = (cumulative << 7) + (octet & 0x7f);\n    } else {\n      values.push((cumulative << 7) + octet);\n      cumulative = 0;\n    }\n  }\n\n  values[0] = (values[1] / 40) >> 0;\n  values[1] = values[1] - values[0] * 40;\n  element.values = values;\n  element.value = values.join('.');\n});\n\nDer.defaultFormatter.on(Der.BIT_STRING, function(element) {\n  element.value = element.buffer;\n});\n\nDer.defaultFormatter.on(Der.OCTET_STRING, function(element) {\n  element.value = element.buffer;\n});\n\nDer.defaultFormatter.on(Der.BMPString, function(element) {\n  var swap = new Buffer(element.buffer.length);\n  for(var index = 0; index+1 < element.buffer.length; index += 2) {\n    swap[index] = element.buffer[index + 1];\n    swap[index+1] = element.buffer[index];\n  }\n  element.value = swap.toString('ucs2');\n});\n\n\nfunction dumpBuffer(buffer, oid) {\n  oid = oid || {};\n  var dec = new Decoder();\n  var leading = '. ';\n  dec.on('element', function(element) {\n    var value = util.inspect((element.value === null) ? '' : element.value );\n    if (value.length > 50){\n      value = value.substr(0, 50);\n    }\n    if (element.tag == Der.OBJECT_IDENTIFIER) {\n      value = value + ' ' + oid[element.value];\n    }\n\n    console.log('%s%s[%d] %s', leading, element.tag, element.length, value);\n    var old = leading;\n    leading = leading + '. ';\n    if (element.tagConstructed ||\n      element.tag == Der.OCTET_STRING ||\n      element.tag == Der.BIT_STRING ||\n      element.tag == Der.CONTEXT_0) {\n      try {\n        element.children = dec.parse(element.buffer);\n      }\n      catch(err) {\n        console.log(leading + '!!' + err.toString());\n      }\n    }\n\n    leading = old;\n  });\n\n  dec.parse(buffer);\n}\n\nexports = module.exports = Der;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/cacheUtils.js":"﻿//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar fs = require('fs');\nvar path = require('path');\nvar utils = require('./utils');\n\nvar CacheUtils = {};\n\nfunction getSpacesFile(context) {\n  if (!context.subscription) {\n    throw new Error('No current subscription when reading spaces file');\n  }\n  return path.join(utils.azureDir(), 'spaces.' + context.subscription + '.json');\n}\n\nfunction getSitesFile(subscription) {\n  if (!subscription) {\n    throw new Error('No current subscription when reading sites file');\n  }\n  return path.join(utils.azureDir(), 'sites.' + subscription + '.json');\n}\n\nfunction existsInArray(arr, valuetobeChecked) {\n  var result = false;\n  if (Array.isArray(arr) && valuetobeChecked) {\n    result = arr.some(function (val) { return utils.ignoreCaseEquals(val, valuetobeChecked); });\n  }\n  return result;\n}\n\nfunction getCommitIdsFile(context) {\n  return path.join(utils.azureDir(), 'commitids.' + context.subscription + '.json');\n}\n\nfunction readSpaces(context, cb) {\n  var cacheFile = getSpacesFile(context);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      if (!err) {\n        var cachedSpaces = JSON.parse(data);\n        if (cachedSpaces && cachedSpaces.length) {\n          // Check if the spaces have the name property with\n          // the right casing for the current version of the\n          // CLI. If not, it probably is a cache file from a\n          // previous version and, in that case, clear it.\n          if (!cachedSpaces[0].name) {\n            clear();\n            return cb && cb(null, []);\n          } else {\n            return cb && cb(err, cachedSpaces);\n          }\n        }\n      }\n\n      return cb && cb(err, null);\n    });\n  }\n\n  return cb && cb(null, []);\n}\n\nfunction saveSpaces(context, spaces, cb) {\n  var cacheFile = getSpacesFile(context);\n  return fs.writeFile(cacheFile, JSON.stringify(spaces, null, 2), function (err) {\n    if(cb) {\n      cb(err, spaces);\n    }\n  });\n}\n\nfunction deleteSpace(context, spaceName, cb) {\n  var cacheFile = getSpacesFile(context);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      var spaces = JSON.parse(data);\n      if (spaces && spaces.length) {\n        for (var i = 0; i < spaces.length; i++) {\n          if (utils.ignoreCaseEquals(spaceName, spaces[i].name)) {\n            spaces.splice(i, 1);\n            return saveSpaces(context, spaces, cb);\n          }\n        }\n      }\n      return cb && cb(err, null);\n    });\n  }\n\n  return cb && cb(null, null);\n}\n\nfunction readSite(subscription, siteName, cb) {\n  var cacheFile = getSitesFile(subscription);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      if (!err) {\n        var sites = JSON.parse(data);\n        if (sites && sites.length) {\n          // Check if the sites have the name property with\n          // the right casing for the current version of the\n          // CLI. If not, it probably is a cache file from a\n          // previous version and, in that case, clear it.\n          if (!sites[0].name) {\n            clear();\n            return cb && cb(null, null);\n          } else {\n            for (var i = 0; i < sites.length; i++) {\n              if (utils.ignoreCaseEquals(siteName, sites[i].name)) {\n                return cb && cb(err, sites[i]);\n              }\n            }\n          }\n        }\n      }\n\n      return cb && cb(err, null);\n    });\n  }\n\n  return cb && cb(null, null);\n}\n\nfunction saveSite(subscription, siteName, site, cb) {\n  if (!site) {\n    throw new Error('Invalid site');\n  }\n  var cacheFile = getSitesFile(subscription);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      var sites = JSON.parse(data);\n      if (sites && sites.length) {\n        var sitefound = 0;\n        for (var i = 0; i < sites.length; i++) {\n          if (utils.ignoreCaseEquals(siteName, sites[i].name)) {\n            sites[i] = site;\n            sitefound = 1;\n            return saveSites(subscription, sites, cb);\n          }\n        }\n        if (!sitefound) {\n          sites.push(site);\n        }\n        return saveSites(subscription, sites, cb);\n      }\n      return saveSites(subscription, [site], cb);\n    });\n  }\n\n  return saveSites(subscription, [site], cb);\n}\n\nfunction deleteSite(subscription, siteName, cb) {\n  var cacheFile = getSitesFile(subscription);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      var sites = JSON.parse(data);\n      var newSites = [];\n      if (sites && sites.length) {\n        for (var i = 0; i < sites.length; i++) {\n          var result = sites[i].name.match(/\\w+/ig);\n          if (!existsInArray(result, siteName)) {\n            newSites.push(sites[i]);\n          }\n        }\n        return saveSites(subscription, newSites, cb);\n      }\n      return cb && cb(err, null);\n    });\n  }\n\n  return cb && cb(null, null);\n}\n\nfunction saveSites(subscription, sites, cb) {\n  var cacheFile = getSitesFile(subscription);\n  return fs.writeFile(cacheFile, JSON.stringify(sites, null, 2), function (err) {\n    if (cb) {\n      cb(err, sites);\n    }\n  });\n}\n\nfunction saveCommitIds(context, deployments, cb) {\n  var cacheFile = getCommitIdsFile(context);\n  var commitIds = deployments.map(function (deployment) {\n    return {\n      shortId: deployment.shortId,\n      id: deployment.id\n    };\n  });\n  return fs.writeFile(cacheFile, JSON.stringify(commitIds, null, 2), function (err) {\n    if (cb) {\n      cb(err, deployments);\n    }\n  });\n}\n\nfunction readCommitId(context, cb) {\n  var cacheFile = getCommitIdsFile(context);\n  if (utils.pathExistsSync(cacheFile)) {\n    return fs.readFile(cacheFile, function (err, data) {\n      var commitIds = JSON.parse(data);\n      if (commitIds && commitIds.length) {\n        for (var i = 0; i < commitIds.length; i++) {\n          if (utils.ignoreCaseEquals(context.shortId, commitIds[i].shortId) ||\n            utils.ignoreCaseEquals(context.shortId, commitIds[i].id)) {\n            return cb && cb(err, commitIds[i].id);\n          }\n        }\n      }\n      return cb && cb(err, null);\n    });\n  }\n\n  return cb && cb(null, null);\n}\n\nfunction clear() {\n  var isDeleted = false;\n  if (utils.pathExistsSync(utils.azureDir())) {\n    var cacheFiles = fs.readdirSync(utils.azureDir());\n    for (var i = 0; i < cacheFiles.length; ++i) {\n      if (/sites[.].+[.]json/.test(cacheFiles[i]) ||\n         /spaces[.].+[.]json/.test(cacheFiles[i]) ||\n         /commitids[.].+[.]json/.test(cacheFiles[i])) {\n        fs.unlinkSync(path.join(utils.azureDir(), cacheFiles[i]));\n        isDeleted = true;\n      }\n    }\n  }\n  return isDeleted;\n}\n\nCacheUtils.readSpaces = readSpaces;\nCacheUtils.saveSpaces = saveSpaces;\nCacheUtils.deleteSpace = deleteSpace;\nCacheUtils.readSite = readSite;\nCacheUtils.saveSite = saveSite;\nCacheUtils.deleteSite = deleteSite;\nCacheUtils.saveSites = saveSites;\nCacheUtils.saveCommitIds = saveCommitIds;\nCacheUtils.readCommitId = readCommitId;\nCacheUtils.clear = clear;\n\nmodule.exports = CacheUtils;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/util/interaction.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar __ = require('underscore');\nvar tty = require('tty');\nvar fs = require('fs');\nvar util = require('util');\nvar tty = require('tty');\n\n/*jshint camelcase:false*/\nvar child_process = require('child_process');\nvar nonInteractiveMode = process.env['AZURE_NON_INTERACTIVE_MODE'];\n\n//this replaces 'command' package's 'prompt'/'confirm'/'choose', which don't \n//work well with winston's async logging.\nvar prompt_pkg = require('prompt');\n\nvar log = require('./logging');\nvar utils = require('./utils');\n\nfunction Interactor(cli) {\n  this.cli = cli;\n  this.istty1 = tty.isatty(1);\n\n  this._initProgressBars();\n}\n\nfunction checkNonInteractiveMode(requiredVar) {\n  if (nonInteractiveMode) {\n    throw new Error(util.format('Currently, the CLI is being run in \\'Non Interactive Mode\\'. ' + \n    'For the current command, \\'%s\\' is a required parameter (see the help). ' + \n    'Please provide it while executing the command. If you wish '+ \n    'to be in \\'Interactive Mode\\' so that the CLI can prompt you for ' + \n    'missing required parameters, please unset the environment variable '+ \n    '\\'AZURE_NON_INTERACTIVE_MODE\\'.', requiredVar));\n  }\n}\n\n__.extend(Interactor.prototype, {\n  \n  _initProgressBars: function() {\n    var self = this;\n    self.progressChars = ['-', '\\\\', '|', '/'];\n    self.progressIndex = 0;\n\n    self.clearBuffer = new Buffer(79);\n    self.clearBuffer.fill(' ');\n    self.clearBuffer = self.clearBuffer.toString();\n  },\n  \n  _drawAndUpdateProgress: function() {\n    var self = this;\n    if (nonInteractiveMode) {\n      return;\n    }\n\n    fs.writeSync(1, '\\r');\n    process.stdout.write(self.progressChars[self.progressIndex].cyan);\n\n    self.progressIndex++;\n    if (self.progressIndex === self.progressChars.length) {\n      self.progressIndex = 0;\n    }\n  },\n\n  clearProgress: function () {\n    var self = this;\n    // do not output '+' if there is no progress\n    if (self.currentProgress) {\n      if (self.activeProgressTimer) {\n        clearInterval(self.activeProgressTimer);\n        self.activeProgressTimer = null;\n      }\n      if (!nonInteractiveMode) {\n        fs.writeSync(1, '\\r+\\n');\n      }\n      self.currentProgress = undefined;\n    }\n  },\n\n  //Not used\n  //writeDuringProgress: function(level, message) {\n  //  if (this.currentProgress) {\n  //    fs.writeSync(1, '\\r' + this.clearBuffer + '\\r');\n  //    log[level](message);\n  //    this._drawAndUpdateProgress();\n  //  }\n  //},\n\n  _pauseProgress: function () {\n    if (nonInteractiveMode) {\n      return;\n    }\n\n    if (this.currentProgress) {\n      fs.writeSync(1, '\\r' + this.clearBuffer + '\\r');\n    }\n  },\n\n  _restartProgress: function (label) {\n    if (nonInteractiveMode) {\n      return;\n    }\n\n    if (this.currentProgress) {\n      this._drawAndUpdateProgress();\n      if (label) {\n        fs.writeSync(1, ' ' + label);\n      }\n    }\n  },\n\n  progress: function(label, log) {\n    var self = this;\n    if (!log && self.cli) {\n      log = self.cli.output;\n    }\n\n    var verbose = log && (log.format().json || log.format().level === 'verbose' || log.format().level === 'silly');\n    if (!self.istty1 || verbose)  {\n      (verbose ? log.verbose : log.info)(label);\n      return {\n        write: function (logAction) {\n          logAction();\n        },\n        end: function() {}\n      };\n    }\n\n    // clear any previous progress\n    self.clearProgress();\n\n    // Clear the console\n    fs.writeSync(1, '\\r' + self.clearBuffer);\n\n    // Draw initial progress\n    self._drawAndUpdateProgress();\n\n    // Draw label\n    if (label) {\n      fs.writeSync(1, ' ' + label);\n    }\n\n    self.activeProgressTimer = setInterval(function() {\n      self._drawAndUpdateProgress();\n    }, 200);\n\n    self.currentProgress = {\n      write: function (logAction, newLabel) {\n        newLabel = newLabel || label;\n        self._pauseProgress();\n        logAction();\n        self._restartProgress(newLabel);\n      },\n      end: function() {\n        self.clearProgress();\n      }\n    };\n\n    return self.currentProgress;\n  },\n\n  withProgress: function (label, action, callback) {\n    var self = this;\n    var p = this.progress(label);\n    var logMsgs = [];\n    var logger = {\n      error: function (message) {\n        logMsgs.push(function () { self.cli.output.error(message); });\n      },\n      info: function (message) {\n        logMsgs.push(function () { self.cli.output.info(message); });\n      },\n      data: function (message) {\n        logMsgs.push(function () { self.cli.output.data(message); });\n      },\n      warn: function (message) {\n        logMsgs.push(function () { self.cli.output.warn(message); });\n      }\n    };\n\n    action.call(p, logger, function () {\n      p.end();\n      logMsgs.forEach(function (lf) { lf(); });\n      callback.apply(null, arguments);\n    });\n  },\n  \n  //behavior verified\n  prompt: function (msg, callback) {\n    checkNonInteractiveMode(msg);\n    prompt_pkg.start();\n    //surpress the default prompt message\n    prompt_pkg.message = '';\n    prompt_pkg.delimiter = '';\n    prompt_pkg.get([{\n        name: msg\n      }], function (err, result) {\n      if (err) return callback(err);\n      if (utils.stringIsNullOrEmpty(result[msg])) {\n        return callback(new Error(util.format('Please provide a non empty ' + \n          'value for \\'%s\\'. You provided - \\'%s\\'.', msg, result[msg])));\n      }\n      callback(null, result[msg]);\n    });\n  },\n  \n  //behavior verified\n  confirm: function (msg, callback) {\n    checkNonInteractiveMode(msg);\n    prompt_pkg.start();\n    //surpress the default prompt message\n    prompt_pkg.message = '';\n    prompt_pkg.delimiter = '';\n    prompt_pkg.confirm(msg, callback);\n  },\n  \n  //behavior verified\n  promptPassword: function (msg, callback) {\n    this.password(msg, '*', function (err, result) {\n      callback(err, result);\n    });\n  },\n  \n  //behavior verified, \"vm quick-create\" uses it\n  promptPasswordIfNotGiven: function (promptString, currentValue, callback) {\n    if (__.isUndefined(currentValue)) {\n      return this.promptPassword(promptString, callback);\n    } else {\n      return callback(null, currentValue);\n    }\n  },\n  \n  //behavior verified, 'promptPasswordOnceIfNotGiven' below uses it.\n  promptPasswordOnce: function (msg, callback) {\n    this.passwordOnce(msg, '*', function (err, result) {\n      callback(err, result);\n    });\n  },\n  \n  //behavior verified, 'login' uses this\n  promptPasswordOnceIfNotGiven: function (promptString, currentValue, callback) {\n    if (__.isUndefined(currentValue)) {\n      this.promptPasswordOnce(promptString, function (err, result) {\n        return callback(err, result);\n      });\n    } else {\n      return callback(null, currentValue);\n    }\n  },\n  \n  //behavior verified\n  promptIfNotGiven: function (promptString, currentValue, callback) {\n    if (__.isUndefined(currentValue)) {\n      return this.prompt(promptString, callback);\n    } else {\n      return callback(null, currentValue);\n    }\n  },\n  \n  //behavior verified\n  choose: function (values, callback) {\n    var self = this;\n    var displays = values.map(function (v, index) {\n      return util.format('  %d) %s', index + 1, v);\n    });\n    var msg = displays.join('\\n') + '\\n:';\n    function again() {\n      self.prompt(msg, function (err, result) {\n        if (err) return callback(err);\n        var selection = parseInt(result, 10) - 1;\n        if (!(values[selection])) {\n          again();\n        } else {\n          callback(null, selection);\n        }\n      });\n    }   \n    again();\n  },\n  \n  //behavior verified\n  chooseIfNotGiven: function (promptString, progressString, currentValue, valueProvider, callback) {\n    var self = this;\n    checkNonInteractiveMode(promptString);\n    if (__.isUndefined(currentValue)) {\n      //comment out the progress usage, as it interferes winton's async logging\n      //var progress = self.cli.interaction.progress(progressString);\n      valueProvider(function (err, values) {\n        if (err) return callback(err);\n        //progress.end();\n        self.cli.output.help(promptString);\n        self.choose(values, function (err, selection) {\n          return callback(err, values[selection]);\n        });\n      });\n    } else {\n      return callback(null, currentValue);\n    }\n  },\n\n  formatOutput: function (outputData, humanOutputGenerator) {\n    this.cli.output.json('silly', outputData);\n    if(this.cli.output.format().json) {\n      this.cli.output.json(outputData);\n    } else {\n      humanOutputGenerator(outputData);\n    }\n  },\n\n  logEachData: function (title, data) {\n    for (var property in data) {\n      if (data.hasOwnProperty(property)) {\n        if (data[property]) {\n          this.cli.output.data(title + ' ' + property, data[property]);\n        } else {\n          this.cli.output.data(title + ' ' + property, '');\n        }\n      }\n    }\n  },\n\n  launchBrowser: function (url, callback) {\n    log.info('Launching browser to', url);\n    if (process.env.OS !== undefined) {\n      // escape & characters for start cmd\n      var cmd = util.format('start %s', url).replace(/&/g, '^&');\n      child_process.exec(cmd, callback);\n    } else {\n      child_process.spawn('open', [url]);\n      callback();\n    }\n  },\n  \n  //the reason of reinventing the wheel, rather use the npm 'prompt' package\n  //is to display the mask of '*' for each character. No idea why we prefered \n  //this behavior, but it is what it is.\n  passwordOnce: function (currentStr, mask, callback) {\n    checkNonInteractiveMode(currentStr);\n    var buf = '';\n\n    // default mask\n    if ('function' === typeof mask) {\n      callback = mask;\n      mask = '';\n    }\n\n    if (!process.stdin.setRawMode) {\n      process.stdin.setRawMode = tty.setRawMode;\n    }\n\n    process.stdin.resume();\n    process.stdin.setRawMode(true);\n    fs.writeSync(this.istty1 ? 1 : 2, currentStr);\n\n    process.stdin.on('data', function (character) {\n      // Exit on Ctrl+C keypress\n      character = character.toString();\n      if (character === '\\003') {\n        console.log('%s', buf);\n        process.exit();\n      }\n\n      // Return password in the buffer on enter key press\n      if (character === '\\015') {\n        process.stdin.pause();\n        process.stdin.removeAllListeners('data');\n        process.stdout.write('\\n');\n        process.stdin.setRawMode(false);\n\n        return callback(null, buf);\n      }\n\n      // Backspace handling\n      // Windows usually sends '\\b' (^H) while Linux sends '\\x7f'\n      if (character === '\\b' || character === '\\x7f') {\n        if (buf) {\n          buf = buf.slice(0, -1);\n          for (var j = 0; j < mask.length; ++j) {\n            process.stdout.write('\\b \\b'); // space the last character out\n          }\n        }\n\n        return;\n      }\n\n      character = character.split('\\015')[0]; // only use the first line if many (for paste)\n      for(var i = 0; i < character.length; ++i) {\n        process.stdout.write(mask); // output several chars (for paste)\n      }\n\n      buf += character;\n    });\n  },\n\n  // Allow cli.password to accept empty passwords\n  password: function (str, mask, callback) {\n    var self = this;\n    checkNonInteractiveMode(str);\n    // Prompt first time\n    this.passwordOnce(str, mask, function (err, pass) {\n      //till today, *err* is always null, so we skip the check.\n      // Prompt for confirmation\n      self.passwordOnce('Confirm password: ', mask, function (err2, pass2) {\n        if (pass === pass2) {\n          return callback(null, pass);\n        } else {\n          throw new Error('Passwords do not match.');\n        }\n      });\n    });\n  }\n});\n\nmodule.exports = Interactor;\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/lib/autocomplete.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\nvar _ = require('underscore');\nvar fs = require('fs');\nvar path = require('path');\n\nvar CmdLoader = require('./cmdLoader');\nvar utilsCore = require('./util/utilsCore');\n\nfunction AutoComplete() {\n  this.mode = utilsCore.getMode();\n  this.cmdMetadataFile = path.join(__dirname, 'plugins.' + this.mode + '.json');\n  this.cmdBasePath = __dirname;\n  var loader = new CmdLoader(this, this.mode);\n  if (loader.cmdMetadataExists()) {\n    this.initFromCmdMetadata();\n  }\n  \n  this.enableAutoComplete();\n}\n\n_.extend(AutoComplete.prototype, {\n  initFromCmdMetadata: function () {\n    var data = fs.readFileSync(this.cmdMetadataFile);\n    var cachedPlugins = JSON.parse(data);\n    this.commands = cachedPlugins.commands;\n    this.categories = cachedPlugins.categories;\n  },\n  \n  enableAutoComplete: function () {\n    var root = this;\n    var omelette = require('omelette');\n    root.autoComplete = omelette('azure');\n    \n    function handleAutocomplete(fragment, word, line) {\n      var args = line.trim().split(' ')\n        .filter(function (a) {\n        return a !== '';\n      }).map(function (c) {\n        return c.trim();\n      });\n      \n      var currentCommand;\n      var arg;\n      var index;\n      var parentCategory;\n      var currentCategory;\n      \n      // start from 1, so to discard \"azure\" word\n      for (index = 1, currentCategory = root; index < args.length; index++) {\n        arg = args[index];\n        parentCategory = currentCategory;\n        currentCategory = currentCategory.categories[arg];\n        if (!currentCategory) {\n          break;\n        }\n      }\n      \n      var tempCategory = currentCategory ? currentCategory : parentCategory;\n      var allSubCategoriesAndCommands = Object.keys(tempCategory.categories)\n        .concat(tempCategory.commands.map(function (c) { return c.name; }));\n      \n      currentCommand = tempCategory.commands\n        .filter(function (c) {return c.name === arg;})[0];\n      \n      //run out argument while have a valid category?\n      if (currentCategory) {\n        //return sub categories and command combind\n        return this.reply(allSubCategoriesAndCommands);\n      }\n      \n      var allCommandOptions;\n      if (currentCommand) {\n        allCommandOptions = currentCommand.options.map(function (o) { return o.long; })\n            .concat(currentCommand.options.map(function (o) { return o.short; }));\n      }\n      //we are at the last arg, try match both categories and commands\n      if (index === args.length - 1) {\n        if (currentCommand) {\n          return this.reply(allCommandOptions);\n        } else {\n          return this.reply(allSubCategoriesAndCommands.filter(function (c) {\n            return utilsCore.stringStartsWith(c, arg);\n          }));\n        }\n      }\n      \n      // try to match a command's options\n      var lastArg = args[args.length - 1];\n      if (currentCommand && utilsCore.stringStartsWith(lastArg, '-')) {\n        var option = currentCommand.options\n          .filter(function (c) {\n            return c.fileRelatedOption && (c.short === lastArg || c.long === lastArg);\n          })[0];\n        \n        if (option) {\n          return this.reply(fs.readdirSync(process.cwd()));\n        } else {\n          return this.reply(\n            allCommandOptions.filter(function (c) { return c && utilsCore.stringStartsWith(c, lastArg);}));\n        }\n      }\n      return this.reply([]);\n    }\n    \n    root.autoComplete.on('complete', handleAutocomplete);\n    root.autoComplete.init();\n  }\n});\n\nmodule.exports = AutoComplete;","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/scripts/extract-labels.js":"var path = require('path');\nvar fs = require('fs');\n\nvar walk = function(dir, done) {\n  var results = [];\n  fs.readdir(dir, function(err, list) {\n    if (err) return done(err);\n    var pending = list.length;\n    if (!pending) return done(null, results);\n    list.forEach(function(file) {\n      file = dir + '/' + file;\n      fs.stat(file, function(err, stat) {\n        if (stat && stat.isDirectory()) {\n          walk(file, function(err, res) {\n            results = results.concat(res);\n            if (!--pending) done(null, results);\n          });\n        } else {\n          results.push(file);\n          if (!--pending) done(null, results);\n        }\n      });\n    });\n  });\n};\n\nwalk(path.join(__dirname, '../lib/commands'), function (err, files) {\n  var results = [];\n\n  files.forEach(function (file) {\n    if (path.extname(file) === '.js' || path.extname(file) === '._js') {\n      var content = fs.readFileSync(file).toString();\n\n      var startIndex = 0;\n      var found;\n      do {\n        foundIndex = content.indexOf('$(', startIndex);\n\n        if (foundIndex >= 0) {\n          var bracketCount = 0;\n          var stop = false;\n          for (var i = foundIndex + '$('.length; !stop && i < content.length; i++) {\n            if (content[i] === '(') {\n              bracketCount++;\n            } else if (content[i] === ')') {\n              if (bracketCount === 0) {\n                var match = content.substr(foundIndex + 3, (i - foundIndex) - 4);\n                match = match.replace(/\\\\'/g, '\\'').replace(/\\\\\\\\/g, '\\\\').replace(/\\\\n/g, '\\n');\n                results.push(match);\n                startIndex = i;\n                stop = true;\n              } else {\n                bracketCount--;\n              }\n            }\n          }\n        }\n      } while (foundIndex > 0);\n    }\n  });\n\n  var sortedKeys = results.sort();\n  var labels = {};\n  sortedKeys.forEach(function (label) {\n    labels[label] = label;\n  });\n\n  fs.writeFileSync(path.join(__dirname, '../lib/locales/en-us.json'), JSON.stringify(labels, null, 4));\n});","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/scripts/filter-testresults.js":"// \n// Copyright (c) Microsoft and contributors.  All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// \n// See the License for the specific language governing permissions and\n// limitations under the License.\n// \n\n'use strict';\n\nvar Stream = require('stream');\nvar fs = require('fs');\nvar os = require('os');\n\nvar EOL = '\\n';\nvar debugStream = null;\nvar deleteInput = false;\nvar source;\n\nifFlag('-rm', function () {\n  deleteInput = true;\n});\n\nifFlag('-debug', function () {\n  debugStream = fs.createWriteStream('filter-debug.log', {flags: 'w'});\n});\n\nif (process.argv.length > 2) {\n  source = fs.createReadStream(process.argv[2], { flags: 'r' });\n  if (deleteInput) {\n    source.on('close', function () {\n      fs.unlinkSync(process.argv[2]);\n    });\n  }\n} else {\n  source = process.stdin;\n}\n\nfunction ifFlag(flag, ifPresentCallback) {\n  var flagIndex = process.argv.indexOf(flag);\n  if (flagIndex !== -1) {\n    process.argv.splice(flagIndex, 1);\n    ifPresentCallback();\n  }\n}\n\n//\n// Through stream that breaks up input into individual\n// lines of text and writes the lines individually.\n// Makes it easier for downstream filters to operate on\n// a per line basis.\n//\n\nfunction lineFilter() {\n  var stream = new Stream();\n  stream.readable = true;\n  stream.writable = true;\n\n  var pendingLines = [];\n  var partialLine = null;\n  var done = false;\n\n  stream.write = write;\n  stream.end = end;\n\n  return stream;\n\n  function sendNextLine() {\n    if (pendingLines.length > 0) {\n      var lineToSend = pendingLines.shift();\n      stream.emit('data', lineToSend + EOL);\n      if(debugStream) {\n        debugStream.write('line filter sending line ' + lineToSend + EOL);\n      }\n      process.nextTick(sendNextLine);\n    } else if (done) {\n      if (partialLine !== null) {\n        stream.emit('data', partialLine + EOL);\n      }\n      stream.emit('end');\n      stream.emit('close');\n    }\n  }\n\n  function splitBufferIntoLines(buffer, encoding, completionCallback) {\n    if (typeof buffer !== 'string') {\n      buffer = buffer.toString(encoding);\n    }\n\n    var lines = buffer.split(EOL);\n    var lastLine = lines[lines.length - 1];\n    if (buffer.slice(-(EOL.length)) !== EOL) {\n      lines.pop();\n    } else {\n      lastLine = null;\n    }\n\n    completionCallback(lines, lastLine);\n  }\n\n  function write(buffer, encoding) {\n    var shouldSend = (pendingLines.length === 0);\n\n    splitBufferIntoLines(buffer, encoding, function (fullLines, leftover) {\n      if (fullLines.length > 0 && partialLine !== null) {\n        fullLines[0] = partialLine + fullLines[0];\n        partialLine = null;\n      }\n\n      if (leftover !== null) {\n        partialLine = (partialLine || '') + leftover;\n      }\n      pendingLines = pendingLines.concat(fullLines);\n    });\n\n    if (shouldSend) {\n      process.nextTick(sendNextLine);\n    }\n  }\n\n  function end(buffer, encoding) {\n    if (buffer) {\n      this.write(buffer, encoding);\n    }\n    done = true;\n  }\n}\n\n//\n// A simple transformation stream that reads in\n// test results and filters out extraneous lines -\n// everything before the first XML <testsuite> line.\n// Assumes that the LineFilter above is included\n// so treats every buffer as a single line.\n//\n\nfunction testResultFilter() {\n  var stream = new Stream();\n  stream.readable = true;\n  stream.writable = true;\n\n  stream.write = write;\n  stream.end = end;\n\n  var xmlFound = false;\n\n  return stream;\n\n  function write(buffer, encoding) {\n    if (typeof buffer !== 'string') {\n      buffer = buffer.toString(encoding);\n    }\n    checkIfXmlFound(buffer);\n    if (xmlFound) {\n      if (debugStream) {\n       debugStream.write('received line '  + buffer + ' and it\\'s in the xml\\n');\n      }\n      var self = this;\n      process.nextTick(function () { self.emit('data', buffer); });\n    } else if (debugStream) {\n      debugStream.write('received line ' + buffer + ' and it\\'s not in the xml\\n');\n    }\n  }\n\n  function end(buffer, encoding) {\n    if (buffer) {\n      if (debugStream) {\n        debugStream.write('>>>>> end received with buffer, writing');\n      }\n      this.write(buffer, encoding);\n    }\n    process.nextTick(function () {\n      stream.emit('end');\n      stream.emit('close');\n    });\n  }\n\n  function checkIfXmlFound(line) {\n    if (xmlFound) { return; }\n    var openTag = '<testsuite';\n    if (line.slice(0, openTag.length) === openTag) {\n      xmlFound = true;\n    }\n  }\n}\n\n//\n// Temporary workaround to tweak output report so that\n// Jenkins will render it.\n//\nfunction changeSkippedFilter() {\n  var stream = new Stream();\n  stream.readable = true;\n  stream.writable = true;\n\n  stream.write = write;\n  stream.end = end;\n  return stream;\n\n  function write(buffer, encoding) {\n    if (typeof buffer !== 'string') {\n      buffer = buffer.toString(encoding);\n    }\n\n    var openTag = '<testsuite';\n    if(buffer.slice(0, openTag.length) === openTag) {\n      buffer = buffer.replace(' skip=\"', ' skipped=\"');\n    }\n    this.emit('data', buffer);\n  }\n\n  function end(buffer, encoding) {\n    if (buffer) {\n      this.write(buffer, encoding);\n    }\n    this.emit('end');\n    this.emit('close');\n  }\n}\n\nsource.resume();\nsource.pipe(lineFilter()).pipe(testResultFilter()).pipe(changeSkippedFilter()).pipe(process.stdout);\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/scripts/generate_command_inventory.js":"//command arguments:\n// if no arguments, output all across asm and arm\n// Or use 'arm' to output all arm ones\n// Or use 'arm vm,network' to output arm\\network, arm\\vm ones\n\nvar cmds = [];\nvar cmdsets;\nvar scope = process.argv[2] || 'all';\nvar filter = process.argv[3] || '';\nvar result = {};\n\ncmdsets = filter ? filter.split(',') : null;\n\nif (scope === 'arm' || scope === 'all') {\n  cmds = cmds.concat(gen('../lib/plugins.arm.json', cmdsets));\n} else if (scope === 'asm' || scope === 'all') {\n  cmds = cmds.concat(gen('../lib/plugins.asm.json', cmdsets));\n} else {\n  console.log('Use scope of \"arm\", \"asm\" or \"all\"');\n}\n\nconsole.log(cmds.join('\\n'));\n\nfunction gen(file, cmdsets) {\n  result = {};\n  var metedata = require(file);\n  parse(metedata, '');\n  var cmds = Object.keys(result).sort();\n  if (cmdsets) {\n    cmds = cmds.filter(function (e) {\n      var t1 = e.trim().split(' ')[0];\n      return cmdsets.indexOf(t1) >= 0;\n    });\n  }\n  return cmds;\n}\n\nfunction parse(cmdObj, category) {\n  if (cmdObj !== null && typeof cmdObj === 'object') {\n    Object.keys(cmdObj).forEach(function (key) {\n      if (key === 'commands') {\n        cmdObj[key].forEach(function (element) {\n          var fullname = category + ' ' + element.name;\n          result[fullname] = element.filePath;\n        });\n      } else if (key === 'categories') {\n        Object.keys(cmdObj[key]).forEach(function (subCategory) {\n          parse(cmdObj[key][subCategory], category + ' ' + subCategory);\n        });\n      }\n    });\n  }\n}","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/scripts/link-to-sdk.js":"var path = require('path');\nvar exec = require('child_process').exec;\n\nvar linkToPrivateRepo = (process.argv[2] && process.argv[2].indexOf('pr') === 0);\n\nvar servicePackages = [\n  'computeManagement',\n  'gallery',\n  'management',\n  'monitoring',\n  'networkManagement',\n  'resourceManagement',\n  'scheduler',\n  'schedulerManagement',\n  'serviceBusManagement',\n  'sqlManagement',\n  'storageManagement',\n  'subscriptionManagement',\n  'webSiteManagement',\n  'authorizationManagement',\n  'extra',\n  'hdinsight',\n  'apiAppManagement'\n];\n\n//\n// This script assumes that the node sdk is sitting next to\n// the xplat cli on the file system. If not, change the\n// below variable to point to it.\n//\n\nvar root = '../' +  (linkToPrivateRepo ? 'azure-sdk-for-node-pr' : 'azure-sdk-for-node');\n\nvar packagesToLink = [ 'lib/common' ].concat(servicePackages.map(function (p) { return 'lib/services/' + p; })).concat('');\n\nvar commands = packagesToLink.map(function (path) {\n  return 'npm link ' + root + '/' + path;\n});\n\nfunction executeCmds(cmds) {\n  if (cmds.length > 0) {\n    var current = cmds.shift();\n    cwd = path.join(__dirname, '/../');\n\n    exec(current, { cwd: cwd }, function (err, stdout, stderr) {\n      if (stdout) {\n        console.log(stdout);\n      }\n      if (stderr) {\n        console.log(stderr);\n      }\n\n      if (err) {\n        console.log(err);\n      } else {\n        executeCmds(cmds);\n      }\n    });\n  }\n}\n\nexecuteCmds(commands);\n","/home/travis/build/npmtest/node-npmtest-azure-cli/node_modules/azure-cli/scripts/unit.js":"//\n// Copyright (c) Microsoft and contributors.  All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\nvar fs = require('fs');\nvar args = (process.ARGV || process.argv);\n\nvar reporter = '../../../test/framework/xcli-test-reporter';\nvar xunitOption = Array.prototype.indexOf.call(args, '-xunit');\nif (xunitOption !== -1) {\n  reporter = 'xunit';\n  args.splice(xunitOption, 1);\n}\n\nvar testList = args.pop();\n\nif (!fs.existsSync) {\n  fs.existsSync = require('path').existsSync;\n}\n\nvar root = fs.existsSync('./package.json');\n\nfunction buildFileList(testFiles, testList, root) {\n  var file = root ? './test/' + testList : testList;\n  var fileContent = fs.readFileSync(file).toString();\n  var files = fileContent.split('\\n');\n  var includeMark = 'include:';\n  for (var i = 0; i < files.length ; i++) {\n    if (files[i].indexOf(includeMark) === 0) {\n      var fileToInclude = files[i].substring(includeMark.length).replace('\\r', '');\n      buildFileList(testFiles, fileToInclude, root);\n    } else {\n      testFiles.push(files[i]);\n    }\n  }\n}\n\nvar allFiles = [];\nbuildFileList(allFiles, testList, root);\n\nargs.push('-u');\nargs.push('tdd');\n\n// TODO: remove this timeout once tests are faster\nargs.push('-t');\nargs.push('1600000');\n\nallFiles.forEach(function (file) {\n  if (file.length > 0 && file.trim()[0] !== '#') {\n    // trim trailing \\r if it exists\n    file = file.replace('\\r', '');\n    var temp = root ? 'test/' + file : file;\n    args.push(temp);\n  }\n});\n\nargs.push('-R');\nargs.push(reporter);\n//for clean shutdown of the event loop, so silly log gets drained to disk.\nargs.push('--no-exit');\n\nconsole.log('Start (' + testList + '):' + new Date().toLocaleTimeString());\n\n//console.log(JSON.stringify(args, null, 2));\n\nprocess.on('exit', function (err) {\n  console.log('End:' + new Date().toLocaleTimeString());\n})\n\nrequire('../node_modules/mocha/bin/mocha');\n"}